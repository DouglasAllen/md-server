<h1 id="the-ruby-programming-language">The Ruby Programming Language</h1>
<h2 id="chapter-9">CHAPTER 9</h2>
<h3 id="the-ruby-platform">The Ruby Platform</h3>
<h4 id="strings">9.1 Strings</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">s = <span class="st">&quot;hello&quot;</span>
s.concat(<span class="st">&quot; world&quot;</span>)    <span class="co"># Synonym for &lt;&lt;. Mutating append to s. Returns new s.</span>
s.insert(<span class="dv">5</span>, <span class="st">&quot; there&quot;</span>) <span class="co"># Same as s[5] = &quot; there&quot;. Alters s. Returns new s.</span>
s.slice(<span class="dv">0</span>,<span class="dv">5</span>)          <span class="co"># Same as s[0,5]. Returns a substring.</span>
s.slice!(<span class="dv">5</span>,<span class="dv">6</span>)         <span class="co"># Deletion. Same as s[5,6]=&quot;&quot;. Returns deleted substring.</span>
s.eql?(<span class="st">&quot;hello world&quot;</span>) <span class="co"># True. Same as ==.</span>
<span class="co">###########################</span>
s.length         <span class="co"># =&gt; 5: counts characters in 1.9, bytes in 1.8</span>
s.size           <span class="co"># =&gt; 5: size is a synonym</span>
s.bytesize       <span class="co"># =&gt; 5: length in bytes; Ruby 1.9 only</span>
s.empty?         <span class="co"># =&gt; false</span>
<span class="st">&quot;&quot;</span>.empty?        <span class="co"># =&gt; true</span>
<span class="co">###########################</span>
s = <span class="st">&quot;hello&quot;</span>
<span class="co"># Finding the position of a substring or pattern match</span>
s.index(<span class="st">&#39;l&#39;</span>)         <span class="co"># =&gt; 2: index of first l in string</span>
s.index(?l)          <span class="co"># =&gt; 2: works with character codes as well</span>
s.index(<span class="ot">/l+/</span>)        <span class="co"># =&gt; 2: works with regular expressions, too</span>
s.index(<span class="st">&#39;l&#39;</span>,<span class="dv">3</span>)       <span class="co"># =&gt; 3: index of first l in string at or after position 3</span>
s.index(<span class="st">&#39;Ruby&#39;</span>)      <span class="co"># =&gt; nil: search string not found</span>
s.rindex(<span class="st">&#39;l&#39;</span>)        <span class="co"># =&gt; 3: index of rightmost l in string</span>
s.rindex(<span class="st">&#39;l&#39;</span>,<span class="dv">2</span>)      <span class="co"># =&gt; 2: index of rightmost l in string at or before 2</span>

<span class="co"># Checking for prefixes and suffixes: Ruby 1.9 and later</span>
s.start_with? <span class="st">&quot;hell&quot;</span> <span class="co"># =&gt; true.  Note singular &quot;start&quot; not &quot;starts&quot;</span>
s.end_with? <span class="st">&quot;bells&quot;</span>  <span class="co"># =&gt; false</span>

<span class="co"># Testing for presence of substring</span>
s.include?(<span class="st">&quot;ll&quot;</span>)     <span class="co"># =&gt; true: &quot;hello&quot; includes &quot;ll&quot;</span>
s.include?(?H)       <span class="co"># =&gt; false: &quot;hello&quot; does not include character H</span>

<span class="co"># Pattern matching with regular expressions</span>
s =~ <span class="ot">/[aeiou]{2}/</span>    <span class="co"># =&gt; nil: no double vowels in &quot;hello&quot;</span>
s.match(<span class="ot">/[aeiou]/</span>) {|m| m.to_s} <span class="co"># =&gt; &quot;e&quot;: return first vowel</span>

<span class="co"># Splitting a string into substrings based on a delimiter string or pattern</span>
<span class="st">&quot;this is it&quot;</span>.split     <span class="co"># =&gt; [&quot;this&quot;, &quot;is&quot;, &quot;it&quot;]: split on spaces by default</span>
<span class="st">&quot;hello&quot;</span>.split(<span class="st">&#39;l&#39;</span>)     <span class="co"># =&gt; [&quot;he&quot;, &quot;&quot;, &quot;o&quot;]</span>
<span class="st">&quot;1, 2,3&quot;</span>.split(<span class="ot">/,\s*/</span>) <span class="co"># =&gt; [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]: comma and optional space delimiter</span>

<span class="co"># Split a string into two parts plus a delimiter. Ruby 1.9 only.</span>
<span class="co"># These methods always return arrays of 3 strings:</span>
<span class="st">&quot;banana&quot;</span>.partition(<span class="st">&quot;an&quot;</span>)  <span class="co"># =&gt; [&quot;b&quot;, &quot;an&quot;, &quot;ana&quot;] </span>
<span class="st">&quot;banana&quot;</span>.rpartition(<span class="st">&quot;an&quot;</span>) <span class="co"># =&gt; [&quot;ban&quot;, &quot;an&quot;, &quot;a&quot;]: start from right</span>
<span class="st">&quot;a123b&quot;</span>.partition(<span class="ot">/\d+/</span>)  <span class="co"># =&gt; [&quot;a&quot;, &quot;123&quot;, &quot;b&quot;]: works with Regexps, too</span>

<span class="co"># Search and replace the first (sub, sub!) or all (gsub, gsub!)</span>
<span class="co"># occurrences of the specified string or pattern.</span>
<span class="co"># More about sub and gsub when we cover regular expressions later.</span>
s.sub(<span class="st">&quot;l&quot;</span>, <span class="st">&quot;L&quot;</span>)            <span class="co"># =&gt; &quot;heLlo&quot;: Just replace first occurrence</span>
s.gsub(<span class="st">&quot;l&quot;</span>, <span class="st">&quot;L&quot;</span>)           <span class="co"># =&gt; &quot;heLLo&quot;: Replace all occurrences</span>
s.sub!(<span class="ot">/(.)(.)/</span>, <span class="st">&#39;\2\1&#39;</span>)   <span class="co"># =&gt; &quot;ehllo&quot;: Match and swap first 2 letters</span>
s.sub!(<span class="ot">/(.)(.)/</span>, <span class="st">&quot;\\2\\1&quot;</span>) <span class="co"># =&gt; &quot;hello&quot;: Double backslashes for double quotes</span>

<span class="co"># sub and gsub can also compute a replacement string with a block</span>
<span class="co"># Match the first letter of each word and capitalize it</span>
<span class="st">&quot;hello world&quot;</span>.gsub(<span class="ot">/\b./</span>) {|match| match.upcase } <span class="co"># =&gt; &quot;Hello World&quot;</span>
<span class="co">###########################</span>
<span class="co"># Case modification methods</span>
s = <span class="st">&quot;world&quot;</span>   <span class="co"># These methods work with ASCII characters only</span>
s.upcase      <span class="co"># =&gt; &quot;WORLD&quot;</span>
s.upcase!     <span class="co"># =&gt; &quot;WORLD&quot;; alter s in place</span>
s.downcase    <span class="co"># =&gt; &quot;world&quot;</span>
s.capitalize  <span class="co"># =&gt; &quot;World&quot;: first letter upper, rest lower</span>
s.capitalize! <span class="co"># =&gt; &quot;World&quot;: alter s in place</span>
s.swapcase    <span class="co"># =&gt; &quot;wORLD&quot;: alter case of each letter</span>

<span class="co"># Case insensitive comparison. (ASCII text only)</span>
<span class="co"># casecmp works like &lt;=&gt; and returns -1 for less, 0 for equal, +1 for greater</span>
<span class="st">&quot;world&quot;</span>.casecmp(<span class="st">&quot;WORLD&quot;</span>)  <span class="co"># =&gt; 0 </span>
<span class="st">&quot;a&quot;</span>.casecmp(<span class="st">&quot;B&quot;</span>)          <span class="co"># =&gt; -1 (&lt;=&gt; returns 1 in this case)</span>
<span class="co">###########################</span>
s = <span class="st">&quot;hello\r\n&quot;</span>      <span class="co"># A string with a line terminator</span>
s.chomp!             <span class="co"># =&gt; &quot;hello&quot;: remove one line terminator from end</span>
s.chomp              <span class="co"># =&gt; &quot;hello&quot;: no line terminator so no change</span>
s.chomp!             <span class="co"># =&gt; nil: return of nil indicates no change made</span>
s.chomp(<span class="st">&quot;o&quot;</span>)         <span class="co"># =&gt; &quot;hell&quot;: remove &quot;o&quot; from end</span>
<span class="dt">$/</span> = <span class="st">&quot;;&quot;</span>             <span class="co"># Set global record separator $/ to semicolon</span>
<span class="st">&quot;hello;&quot;</span>.chomp       <span class="co"># =&gt; &quot;hello&quot;: now chomp removes semicolons and end</span>

<span class="co"># chop removes trailing character or line terminator (\n, \r, or \r\n)</span>
s = <span class="st">&quot;hello\n&quot;</span>
s.chop!              <span class="co"># =&gt; &quot;hello&quot;: line terminator removed. s modified.</span>
s.chop               <span class="co"># =&gt; &quot;hell&quot;: last character removed. s not modified.</span>
<span class="st">&quot;&quot;</span>.chop              <span class="co"># =&gt; &quot;&quot;: no characters to remove</span>
<span class="st">&quot;&quot;</span>.chop!             <span class="co"># =&gt; nil: nothing changed</span>

<span class="co"># Strip all whitespace (including \t, \r, \n) from left, right, or both</span>
<span class="co"># strip!, lstrip! and rstrip! modify the string in place.</span>
s = <span class="st">&quot;\t hello \n&quot;</span>   <span class="co"># Whitespace at beginning and end</span>
s.strip             <span class="co"># =&gt; &quot;hello&quot;</span>
s.lstrip            <span class="co"># =&gt; &quot;hello \n&quot;</span>
s.rstrip            <span class="co"># =&gt; &quot;\t hello&quot;</span>

<span class="co"># Left-justify, right-justify, or center a string in a field n-characters wide.</span>
<span class="co"># There are no mutator versions of these methods. See also printf method.</span>
s = <span class="st">&quot;x&quot;</span>
s.ljust(<span class="dv">3</span>)          <span class="co"># =&gt; &quot;x  &quot;</span>
s.rjust(<span class="dv">3</span>)          <span class="co"># =&gt; &quot;  x&quot;</span>
s.center(<span class="dv">3</span>)         <span class="co"># =&gt; &quot; x &quot;</span>
s.center(<span class="dv">5</span>, <span class="st">&#39;-&#39;</span>)    <span class="co"># =&gt; &quot;--x--&quot;: padding other than space are allowed</span>
s.center(<span class="dv">7</span>, <span class="st">&#39;-=&#39;</span>)   <span class="co"># =&gt; &quot;-=-x-=-&quot;: multicharacter padding allowed</span>
<span class="co">###########################</span>
s = <span class="st">&quot;A\nB&quot;</span>                       <span class="co"># Three ASCII characters on two lines</span>
s.each_byte {|b| print b, <span class="st">&quot; &quot;</span> }  <span class="co"># Prints &quot;65 10 66 &quot;</span>
s.each_line {|l| print l.chomp}  <span class="co"># Prints &quot;AB&quot;</span>

<span class="co"># Sequentially iterate characters as 1-character strings</span>
<span class="co"># Works in Ruby 1.9, or in 1.8 with the jcode library:</span>
s.each_char { |c| print c, <span class="st">&quot; &quot;</span> } <span class="co"># Prints &quot;A \n B &quot;</span>

<span class="co"># Enumerate each character as a 1-character string</span>
<span class="co"># This does not work for multibyte strings in 1.8</span>
<span class="co"># It works (inefficiently) for multibyte strings in 1.9:</span>
<span class="dv">0</span>.upto(s.length<span class="dv">-1</span>) {|n| print s[n,<span class="dv">1</span>], <span class="st">&quot; &quot;</span>}

<span class="co"># In Ruby 1.9, bytes, lines, and chars are aliases</span>
s.bytes.to_a                     <span class="co"># =&gt; [65,10,66]: alias for each_byte</span>
s.lines.to_a                     <span class="co"># =&gt; [&quot;A\n&quot;,&quot;B&quot;]: alias for each_line</span>
s.chars.to_a                     <span class="co"># =&gt; [&quot;A&quot;, &quot;\n&quot;, &quot;B&quot;] alias for each_char</span>
<span class="co">###########################</span>
<span class="st">&quot;10&quot;</span>.to_i          <span class="co"># =&gt; 10: convert string to integer</span>
<span class="st">&quot;10&quot;</span>.to_i(<span class="dv">2</span>)       <span class="co"># =&gt; 2: argument is radix: between base-2 and base-36</span>
<span class="st">&quot;10x&quot;</span>.to_i         <span class="co"># =&gt; 10: nonnumeric suffix is ignored. Same for oct, hex</span>
<span class="st">&quot; 10&quot;</span>.to_i         <span class="co"># =&gt; 10: leading whitespace ignored</span>
<span class="st">&quot;ten&quot;</span>.to_i         <span class="co"># =&gt; 0: does not raise exception on bad input</span>
<span class="st">&quot;10&quot;</span>.oct           <span class="co"># =&gt; 8: parse string as base-8 integer</span>
<span class="st">&quot;10&quot;</span>.hex           <span class="co"># =&gt; 16: parse string as hexadecimal integer</span>
<span class="st">&quot;0xff&quot;</span>.hex         <span class="co"># =&gt; 255: hex numbers may begin with 0x prefix</span>
<span class="st">&quot; 1.1 dozen&quot;</span>.to_f  <span class="co"># =&gt; 1.1: parse leading floating-point number</span>
<span class="st">&quot;6.02e23&quot;</span>.to_f     <span class="co"># =&gt; 6.02e+23: exponential notation supported</span>

<span class="st">&quot;one&quot;</span>.to_sym       <span class="co"># =&gt; :one -- string to symbol conversion</span>
<span class="st">&quot;two&quot;</span>.intern       <span class="co"># =&gt; :two -- intern is a synonym for to_sym</span>
<span class="co">###########################</span>
<span class="co"># Increment a string:</span>
<span class="st">&quot;a&quot;</span>.succ                      <span class="co"># =&gt; &quot;b&quot;: the successor of &quot;a&quot;. Also, succ!</span>
<span class="st">&quot;aaz&quot;</span>.next                    <span class="co"># =&gt; &quot;aba&quot;: next is a synonym. Also, next!</span>
<span class="st">&quot;a&quot;</span>.upto(<span class="st">&quot;e&quot;</span>) {|c| print c }  <span class="co"># Prints &quot;abcde. upto iterator based on succ.</span>

<span class="co"># Reverse a string:</span>
<span class="st">&quot;hello&quot;</span>.reverse     <span class="co"># =&gt; &quot;olleh&quot;. Also reverse!</span>

<span class="co"># Debugging</span>
<span class="st">&quot;hello\n&quot;</span>.dump      <span class="co"># =&gt; &quot;\&quot;hello\\n\&quot;&quot;: Escape special characters</span>
<span class="st">&quot;hello\n&quot;</span>.inspect   <span class="co"># Works much like dump</span>

<span class="co"># Translation from one set of characters to another</span>
<span class="st">&quot;hello&quot;</span>.tr(<span class="st">&quot;aeiou&quot;</span>, <span class="st">&quot;AEIOU&quot;</span>)  <span class="co"># =&gt; &quot;hEllO&quot;: capitalize vowels. Also tr!</span>
<span class="st">&quot;hello&quot;</span>.tr(<span class="st">&quot;aeiou&quot;</span>, <span class="st">&quot; &quot;</span>)      <span class="co"># =&gt; &quot;h ll &quot;: convert vowels to spaces</span>
<span class="st">&quot;bead&quot;</span>.tr_s(<span class="st">&quot;aeiou&quot;</span>, <span class="st">&quot; &quot;</span>)     <span class="co"># =&gt; &quot;b d&quot;: convert and remove duplicates</span>

<span class="co"># Checksums</span>
<span class="st">&quot;hello&quot;</span>.sum          <span class="co"># =&gt; 532: weak 16-bit checksum</span>
<span class="st">&quot;hello&quot;</span>.sum(<span class="dv">8</span>)       <span class="co"># =&gt; 20: 8 bit checksum instead of 16 bit</span>
<span class="st">&quot;hello&quot;</span>.crypt(<span class="st">&quot;ab&quot;</span>)  <span class="co"># =&gt; &quot;abl0JrMf6tlhw&quot;: one way cryptographic checksum</span>
                     <span class="co"># Pass two alphanumeric characters as &quot;salt&quot;</span>
                     <span class="co"># The result may be platform-dependent</span>

<span class="co"># Counting letters, deleting letters, and removing duplicates</span>
<span class="st">&quot;hello&quot;</span>.count(<span class="st">&#39;aeiou&#39;</span>)  <span class="co"># =&gt; 2: count lowercase vowels</span>
<span class="st">&quot;hello&quot;</span>.delete(<span class="st">&#39;aeiou&#39;</span>) <span class="co"># =&gt; &quot;hll&quot;: delete lowercase vowels. Also delete!</span>
<span class="st">&quot;hello&quot;</span>.squeeze(<span class="st">&#39;a-z&#39;</span>)  <span class="co"># =&gt; &quot;helo&quot;: remove runs of letters. Also squeeze!</span>
<span class="co"># When there is more than one argument, take the intersection.</span>
<span class="co"># Arguments that begin with ^ are negated.</span>
<span class="st">&quot;hello&quot;</span>.count(<span class="st">&#39;a-z&#39;</span>, <span class="st">&#39;^aeiou&#39;</span>)   <span class="co"># =&gt; 3: count lowercase consonants</span>
<span class="st">&quot;hello&quot;</span>.delete(<span class="st">&#39;a-z&#39;</span>, <span class="st">&#39;^aeiou&#39;</span>)  <span class="co"># =&gt; &quot;eo: delete lowercase consonants</span></code></pre></div>
<h4 id="formatting-text">9.1.1 Formatting Text</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">n, animal = <span class="dv">2</span>, <span class="st">&quot;mice&quot;</span>
<span class="st">&quot;</span><span class="ot">#{</span>n<span class="dv">+1</span><span class="ot">}</span><span class="st"> blind </span><span class="ot">#{</span>animal<span class="ot">}</span><span class="st">&quot;</span>  <span class="co"># =&gt; &#39;3 blind mice&#39;</span>
<span class="co">###########################</span>
<span class="co"># Alternatives to the interpolation above</span>
printf(<span class="st">&#39;%d blind %s&#39;</span>, n<span class="dv">+1</span>, animal)  <span class="co"># Prints &#39;3 blind mice&#39;, returns nil</span>
sprintf(<span class="st">&#39;%d blind %s&#39;</span>, n<span class="dv">+1</span>, animal) <span class="co"># =&gt; &#39;3 blind mice&#39;</span>
<span class="st">&#39;%d blind %s&#39;</span> % [n<span class="dv">+1</span>, animal]  <span class="co"># Use array on right if more than one argument</span>

<span class="co"># Formatting numbers</span>
<span class="st">&#39;%d&#39;</span> % <span class="dv">10</span>         <span class="co"># =&gt; &#39;10&#39;: %d for decimal integers</span>
<span class="st">&#39;%x&#39;</span> % <span class="dv">10</span>         <span class="co"># =&gt; &#39;a&#39;: hexadecimal integers</span>
<span class="st">&#39;%X&#39;</span> % <span class="dv">10</span>         <span class="co"># =&gt; &#39;A&#39;: uppercase hexadecimal integers</span>
<span class="st">&#39;%o&#39;</span> % <span class="dv">10</span>         <span class="co"># =&gt; &#39;12&#39;: octal integers</span>
<span class="st">&#39;%f&#39;</span> % <span class="fl">1234.567</span>   <span class="co"># =&gt; &#39;1234.567000&#39;: full-length floating-point numbers</span>
<span class="st">&#39;%e&#39;</span> % <span class="fl">1234.567</span>   <span class="co"># =&gt; &#39;1.234567e+03&#39;: force exponential notation</span>
<span class="st">&#39;%E&#39;</span> % <span class="fl">1234.567</span>   <span class="co"># =&gt; &#39;1.234567e+03&#39;: exponential with uppercase E</span>
<span class="st">&#39;%g&#39;</span> % <span class="fl">1234.567</span>   <span class="co"># =&gt; &#39;1234.57&#39;: six significant digits</span>
<span class="st">&#39;%g&#39;</span> % <span class="fl">1.23456E12</span> <span class="co"># =&gt; &#39;1.23456e+12&#39;: Use %f or %e depending on magnitude</span>

<span class="co"># Field width</span>
<span class="st">&#39;%5s&#39;</span> % <span class="st">&#39;&lt;&lt;&lt;&#39;</span>     <span class="co"># &#39;  &lt;&lt;&lt;&#39;: right-justify in field five characters wide</span>
<span class="st">&#39;%-5s&#39;</span> % <span class="st">&#39;&gt;&gt;&gt;&#39;</span>    <span class="co"># &#39;&gt;&gt;&gt;  &#39;: left-justify in field five characters wide</span>
<span class="st">&#39;%5d&#39;</span> % <span class="dv">123</span>       <span class="co"># &#39;  123&#39;: field is five characters wide</span>
<span class="st">&#39;%05d&#39;</span> % <span class="dv">123</span>      <span class="co"># &#39;00123&#39;: pad with zeros in field five characters wide</span>

<span class="co"># Precision</span>
<span class="st">&#39;%.2f&#39;</span> % <span class="fl">123.456</span>  <span class="co"># &#39;123.46&#39;: two digits after decimal place</span>
<span class="st">&#39;%.2e&#39;</span> % <span class="fl">123.456</span>  <span class="co"># &#39;1.23e+02&#39;: two digits after decimal = three significant digits</span>
<span class="st">&#39;%.6e&#39;</span> % <span class="fl">123.456</span>  <span class="co"># &#39;1.234560e+02&#39;: note added zero </span>
<span class="st">&#39;%.4g&#39;</span> % <span class="fl">123.456</span>  <span class="co"># &#39;123.5&#39;: four significant digits</span>

<span class="co"># Field and precision combined</span>
<span class="st">&#39;%6.4g&#39;</span> % <span class="fl">123.456</span> <span class="co"># &#39; 123.5&#39;: four significant digits in field six chars wide</span>
<span class="st">&#39;%3s&#39;</span> % <span class="st">&#39;ruby&#39;</span>    <span class="co"># &#39;ruby&#39;: string argument exceeds field width</span>
<span class="st">&#39;%3.3s&#39;</span> % <span class="st">&#39;ruby&#39;</span>  <span class="co"># &#39;rub&#39;: precision forces truncation of string</span>

<span class="co"># Multiple arguments to be formatted</span>
args = [<span class="st">&#39;Syntax Error&#39;</span>, <span class="st">&#39;test.rb&#39;</span>, <span class="dv">20</span>]  <span class="co"># An array of arguments</span>
<span class="st">&quot;%s: in &#39;%s&#39; line %d&quot;</span> % args    <span class="co"># =&gt; &quot;Syntax Error: in &#39;test.rb&#39; line 20&quot; </span>
<span class="co"># Same args, interpolated in different order!  Good for internationalization.</span>
<span class="st">&quot;%2$s:%3$d: %1$s&quot;</span> % args        <span class="co"># =&gt; &quot;test.rb:20: Syntax Error&quot;</span></code></pre></div>
<h4 id="packing-and-unpacking-binary-strings">9.1.2 Packing and Unpacking Binary Strings</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">a = [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]  <span class="co"># An array of 10 integers</span>
b = a.pack(<span class="st">&#39;i10&#39;</span>)           <span class="co"># Pack 10 4-byte integers (i) into binary string b</span>
c = b.unpack(<span class="st">&#39;i*&#39;</span>)          <span class="co"># Decode all (*) the 4-byte integers from b</span>
c == a                      <span class="co"># =&gt; true</span>

m = <span class="st">&#39;hello world&#39;</span>           <span class="co"># A message to encode</span>
data = [m.size, m]          <span class="co"># Length first, then the bytes</span>
template = <span class="st">&#39;Sa*&#39;</span>            <span class="co"># Unsigned short, any number of ASCII chars</span>
b = data.pack(template)     <span class="co"># =&gt; &quot;\v\000hello world&quot;</span>
b.unpack(template)          <span class="co"># =&gt; [11, &quot;hello world&quot;]</span></code></pre></div>
<h4 id="regexp-literals">9.2.1 Regexp Literals</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="ot">/Ruby?/</span>  <span class="co"># Matches the text &quot;Rub&quot; followed by an optional &quot;y&quot;</span>
<span class="co">###########################</span>
<span class="ot">/ruby?/i</span>  <span class="co"># Case-insensitive: matches &quot;ruby&quot; or &quot;RUB&quot;, etc.</span>
<span class="ot">/./mu</span>     <span class="co"># Matches Unicode characters in Multiline mode</span>
<span class="co">###########################</span>
<span class="ot">%r|/|         </span><span class="co"># Matches a single slash character, no escape required</span>
<span class="ot">%r[&lt;/(.*)&gt;]i</span>  <span class="co"># Flag characters are allowed with this syntax, too</span>
<span class="co">###########################</span>
<span class="ot">/\(\)/</span>     <span class="co"># Matches open and close parentheses</span>
<span class="ot">/\\/       # Matches a single backslash</span>
<span class="ot">###########################</span>
<span class="ot">money = /</span>[<span class="dt">$\</span>u20AC\u{a3}\u{a5}]/ <span class="co"># match dollar,euro,pound, or yen sign</span>
<span class="co">###########################</span>
prefix = <span class="st">&quot;,&quot;</span>
<span class="ot">/#{</span>prefix<span class="ot">}\t/</span>   <span class="co"># Matches a comma followed by an ASCII TAB character</span>
<span class="co">###########################</span>
[<span class="dv">1</span>,<span class="dv">2</span>].map{|x| <span class="ot">/#{</span>x<span class="ot">}/</span>}   <span class="co"># =&gt; [/1/, /2/]</span>
[<span class="dv">1</span>,<span class="dv">2</span>].map{|x| <span class="ot">/#{</span>x<span class="ot">}/o</span>}  <span class="co"># =&gt; [/1/, /1/]</span></code></pre></div>
<h4 id="regexp-factory-methods">9.2.2 Regexp Factory Methods</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="dt">Regexp</span>.new(<span class="st">&quot;Ruby?&quot;</span>)                          <span class="co"># /Ruby?/</span>
<span class="dt">Regexp</span>.new(<span class="st">&quot;ruby?&quot;</span>, <span class="dt">Regexp</span>::<span class="dt">IGNORECASE</span>)      <span class="co"># /ruby?/i</span>
<span class="dt">Regexp</span>.compile(<span class="st">&quot;.&quot;</span>, <span class="dt">Regexp</span>::<span class="dt">MULTILINE</span>, <span class="st">&quot;u&quot;</span>)  <span class="co"># /./mu</span>
<span class="co">###########################</span>
pattern = <span class="st">&quot;[a-z]+&quot;</span>                <span class="co"># One or more letters</span>
suffix = <span class="dt">Regexp</span>.escape(<span class="st">&quot;()&quot;</span>)      <span class="co"># Treat these characters literally</span>
r = <span class="dt">Regexp</span>.new(pattern + suffix)  <span class="co"># /[a-z]+\(\)/</span>
<span class="co">###########################</span>
<span class="co"># Match any one of five language names.</span>
pattern = <span class="dt">Regexp</span>.union(<span class="st">&quot;Ruby&quot;</span>, <span class="st">&quot;Perl&quot;</span>, <span class="st">&quot;Python&quot;</span>, <span class="ot">/Java(Script)?/</span>)
<span class="co"># Match empty parens, brackets, or braces. Escaping is automatic:</span>
<span class="dt">Regexp</span>.union(<span class="st">&quot;()&quot;</span>, <span class="st">&quot;[]&quot;</span>, <span class="st">&quot;{}&quot;</span>)   <span class="co"># =&gt; /\(\)|\[\]|\{\}/</span></code></pre></div>
<h4 id="regular-expression-syntax">9.2.3 Regular Expression Syntax</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># Literal characters</span>
<span class="ot">/ruby/</span>             <span class="co"># Match &quot;ruby&quot;. Most characters simply match themselves.</span>
<span class="ot">/&amp;#xA5;/</span>                <span class="co"># Matches Yen sign. Multibyte characters are suported</span>
                   <span class="co"># in Ruby 1.9 and Ruby 1.8.</span>

<span class="co"># Character classes</span>
<span class="ot">/[Rr]uby/</span>          <span class="co"># Match &quot;Ruby&quot; or &quot;ruby&quot;</span>
<span class="ot">/rub[ye]/</span>          <span class="co"># Match &quot;ruby&quot; or &quot;rube&quot;</span>
<span class="ot">/[aeiou]/</span>          <span class="co"># Match any one lowercase vowel</span>
<span class="ot">/[0-9]/</span>            <span class="co"># Match any digit; same as /[0123456789]/</span>
<span class="ot">/[a-z]/</span>            <span class="co"># Match any lowercase ASCII letter</span>
<span class="ot">/[A-Z]/</span>            <span class="co"># Match any uppercase ASCII letter</span>
<span class="ot">/[a-zA-Z0-9]/</span>      <span class="co"># Match any of the above</span>
<span class="ot">/[^aeiou]/</span>         <span class="co"># Match anything other than a lowercase vowel</span>
<span class="ot">/[^0-9]            # Match anything other than a digit</span>

<span class="ot"># Special character classes</span>
<span class="ot">/</span>.<span class="ot">/                # Match any character except newline</span>
<span class="ot">/</span>.<span class="ot">/m               # In multiline mode . matches newline, too</span>
<span class="ot">/</span>\d/               <span class="co"># Match a digit /[0-9]/</span>
<span class="ot">/\D/</span>               <span class="co"># Match a nondigit: /[^0-9]/</span>
<span class="ot">/\s/</span>               <span class="co"># Match a whitespace character: /[ \t\r\n\f]/</span>
<span class="ot">/\S/</span>               <span class="co"># Match nonwhitespace: /[^ \t\r\n\f]/</span>
<span class="ot">/\w/</span>               <span class="co"># Match a single word character: /[A-Za-z0-9_]/</span>
<span class="ot">/\W/</span>               <span class="co"># Match a nonword character: /[^A-Za-z0-9_]/</span>

<span class="co"># Repetition</span>
<span class="ot">/ruby?/</span>            <span class="co"># Match &quot;rub&quot; or &quot;ruby&quot;: the y is optional</span>
<span class="ot">/ruby*/</span>            <span class="co"># Match &quot;rub&quot; plus 0 or more ys</span>
<span class="ot">/ruby+/</span>            <span class="co"># Match &quot;rub&quot; plus 1 or more ys</span>
<span class="ot">/\d{3}/</span>            <span class="co"># Match exactly 3 digits</span>
<span class="ot">/\d{3,}/</span>           <span class="co"># Match 3 or more digits</span>
<span class="ot">/\d{3,5}/</span>          <span class="co"># Match 3, 4, or 5 digits</span>

<span class="co"># Nongreedy repetition: match the smallest number of repetitions</span>
<span class="ot">/&lt;.*&gt;/</span>             <span class="co"># Greedy repetition: matches &quot;&lt;ruby&gt;perl&gt;&quot;</span>
<span class="ot">/&lt;.*?&gt;/</span>            <span class="co"># Nongreedy: matches &quot;&lt;ruby&gt;&quot; in &quot;&lt;ruby&gt;perl&gt;&quot; </span>
                   <span class="co"># Also nongreedy: ??, +?, and {n,m}?</span>

<span class="co"># Grouping with parentheses</span>
<span class="ot">/\D\d+/</span>            <span class="co"># No group: + repeats \d</span>
<span class="ot">/(\D\d)+/</span>          <span class="co"># Grouped: + repeats \D\d pair</span>
<span class="ot">/([Rr]uby(, )?)+/</span>  <span class="co"># Match &quot;Ruby&quot;, &quot;Ruby, ruby, ruby&quot;, etc.</span>

<span class="co"># Backreferences: matching a previously matched group again</span>
<span class="ot">/([Rr])uby&amp;\1ails/</span> <span class="co"># Match ruby&amp;rails or Ruby&amp;Rails</span>
<span class="ot">/([&#39;&quot;])[^\1]*\1/</span>   <span class="co"># Single or double-quoted string</span>
                   <span class="co">#   \1 matches whatever the 1st group matched</span>
                   <span class="co">#   \2 matches whatever the 2nd group matched, etc.</span>

<span class="co"># Named groups and backreferences in Ruby 1.9: match a 4-letter palindrome</span>
<span class="ot">/(?&lt;first&gt;\w)(?&lt;second&gt;\w)\k&lt;second&gt;\k&lt;first&gt;/</span>
<span class="ot">/(?&#39;first&#39;\w)(?&#39;second&#39;\w)\k&#39;second&#39;\k&#39;first&#39;/</span> <span class="co"># Alternate syntax</span>

<span class="co"># Alternatives</span>
<span class="ot">/ruby|rube/</span>        <span class="co"># Match &quot;ruby&quot; or &quot;rube&quot;</span>
<span class="ot">/rub(y|le))/</span>       <span class="co"># Match &quot;ruby&quot; or &quot;ruble&quot;</span>
<span class="ot">/ruby(!+|\?)/</span>      <span class="co"># &quot;ruby&quot; followed by one or more ! or one ?</span>

<span class="co"># Anchors: specifying match position</span>
<span class="ot">/^Ruby/</span>            <span class="co"># Match &quot;Ruby&quot; at the start of a string or internal line</span>
<span class="ot">/Ruby$/</span>            <span class="co"># Match &quot;Ruby&quot; at the end of a string or line</span>
<span class="ot">/\ARuby/</span>           <span class="co"># Match &quot;Ruby&quot; at the start of a string</span>
<span class="ot">/Ruby\Z/</span>           <span class="co"># Match &quot;Ruby&quot; at the end of a string</span>
<span class="ot">/\bRuby\b/</span>         <span class="co"># Match &quot;Ruby&quot; at a word boundary</span>
<span class="ot">/\brub\B/</span>          <span class="co"># \B is nonword boundary:</span>
                   <span class="co">#   match &quot;rub&quot; in &quot;rube&quot; and &quot;ruby&quot; but not alone</span>
<span class="ot">/Ruby(?=!)/</span>        <span class="co"># Match &quot;Ruby&quot;, if followed by an exclamation point</span>
<span class="ot">/Ruby(?!!)/</span>        <span class="co"># Match &quot;Ruby&quot;, if not followed by an exclamation point</span>

<span class="co"># Special syntax with parentheses</span>
<span class="ot">/R(?#comment)/</span>     <span class="co"># Matches &quot;R&quot;. All the rest is a comment</span>
<span class="ot">/R(?i)uby/</span>         <span class="co"># Case-insensitive while matching &quot;uby&quot;</span>
<span class="ot">/R(?i:uby)/</span>        <span class="co"># Same thing</span>
<span class="ot">/rub(?:y|le))/</span>     <span class="co"># Group only without creating \1 backreference</span>

<span class="co"># The x option allows comments and ignores whitespace</span>
<span class="ot">/  # This is not a Ruby comment. It is a literal part</span>
<span class="ot">   # of the regular expression, but is ignored.</span>
<span class="ot">   R      # Match a single letter R</span>
<span class="ot">   (uby)+ # Followed by one or more &quot;uby&quot;s</span>
<span class="ot">   \      # Use backslash for a nonignored space</span>
<span class="ot">/x</span>                 <span class="co"># Closing delimiter. Don&#39;t forget the x option!</span></code></pre></div>
<h4 id="pattern-matching-with-regular-expressions">9.2.4 Pattern Matching with Regular Expressions</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">pattern = <span class="ot">/Ruby?/i</span>      <span class="co"># Match &quot;Rub&quot; or &quot;Ruby&quot;, case-insensitive</span>
pattern =~ <span class="st">&quot;backrub&quot;</span>    <span class="co"># Returns 4.</span>
<span class="st">&quot;rub ruby&quot;</span> =~ pattern   <span class="co"># 0</span>
pattern =~ <span class="st">&quot;r&quot;</span>          <span class="co"># nil</span>
<span class="co">###########################</span>
<span class="st">&quot;hello&quot;</span> =~ <span class="ot">/e\w{2}/</span>     <span class="co"># 1: Match an e followed by 2 word characters</span>
<span class="dt">$~</span>.string               <span class="co"># &quot;hello&quot;: the complete string</span>
<span class="dt">$~</span>.to_s                 <span class="co"># &quot;ell&quot;: the portion that matched</span>
<span class="dt">$~</span>.pre_match            <span class="co"># &quot;h&quot;: the portion before the match</span>
<span class="dt">$~</span>.post_match           <span class="co"># &quot;o&quot;: the portion after the match</span>
<span class="co">###########################</span>
<span class="co"># This is a pattern with three subpatterns</span>
pattern = <span class="ot">/(Ruby|Perl)(\s+)(rocks|sucks)!/</span> 
text = <span class="st">&quot;Ruby\trocks!&quot;</span>     <span class="co"># Text that matches the pattern    </span>
pattern =~ text           <span class="co"># =&gt; 0: pattern matches at the first character</span>
data = <span class="dt">Regexp</span>.last_match  <span class="co"># =&gt; Get match details</span>
data.size                 <span class="co"># =&gt; 4: MatchData objects behave like arrays</span>
data[<span class="dv">0</span>]                   <span class="co"># =&gt; &quot;Ruby\trocks!&quot;: the complete matched text</span>
data[<span class="dv">1</span>]                   <span class="co"># =&gt; &quot;Ruby&quot;: text matching first subpattern</span>
data[<span class="dv">2</span>]                   <span class="co"># =&gt; &quot;\t&quot;: text matching second subpattern</span>
data[<span class="dv">3</span>]                   <span class="co"># =&gt; &quot;rocks&quot;: text matching third subpattern</span>
data[<span class="dv">1</span>,<span class="dv">2</span>]                 <span class="co"># =&gt; [&quot;Ruby&quot;, &quot;\t&quot;]</span>
data[<span class="dv">1</span>..<span class="dv">3</span>]                <span class="co"># =&gt; [&quot;Ruby&quot;, &quot;\t&quot;, &quot;rocks&quot;]</span>
data.values_at(<span class="dv">1</span>,<span class="dv">3</span>)       <span class="co"># =&gt; [&quot;Ruby&quot;, &quot;rocks&quot;]: only selected indexes</span>
data.captures             <span class="co"># =&gt; [&quot;Ruby&quot;, &quot;\t&quot;, &quot;rocks&quot;]: only subpatterns</span>
<span class="dt">Regexp</span>.last_match(<span class="dv">3</span>)      <span class="co"># =&gt; &quot;rocks&quot;: same as Regexp.last_match[3]</span>

<span class="co"># Start and end positions of matches</span>
data.begin(<span class="dv">0</span>)             <span class="co"># =&gt; 0: start index of entire match</span>
data.begin(<span class="dv">2</span>)             <span class="co"># =&gt; 4: start index of second subpattern</span>
data.end(<span class="dv">2</span>)               <span class="co"># =&gt; 5: end index of second subpattern</span>
data.offset(<span class="dv">3</span>)            <span class="co"># =&gt; [5,10]: start and end of third subpattern</span>
<span class="co">###########################</span>
<span class="co"># Ruby 1.9 only</span>
pattern = <span class="ot">/(?&lt;lang&gt;Ruby|Perl) (?&lt;ver&gt;\d(\.\d)+) (?&lt;review&gt;rocks|sucks)!/</span> 
<span class="kw">if</span> (pattern =~ <span class="st">&quot;Ruby 1.9.1 rocks!&quot;</span>)
  <span class="dt">$~</span>[<span class="st">:lang</span>]            <span class="co"># =&gt; &quot;Ruby&quot;</span>
  <span class="dt">$~</span>[<span class="st">:ver</span>]             <span class="co"># =&gt; &quot;1.9.1&quot;</span>
  <span class="dt">$~</span>[<span class="st">&quot;review&quot;</span>]         <span class="co"># =&gt; &quot;rocks&quot;</span>
  <span class="dt">$~</span>.offset(<span class="st">:ver</span>)      <span class="co"># =&gt; [5,10] start and end offsets of version number</span>
<span class="kw">end</span>
<span class="co"># Names of capturing groups and a map of group names to group numbers</span>
pattern.names          <span class="co"># =&gt; [&quot;lang&quot;, &quot;ver&quot;, &quot;review&quot;]</span>
pattern.named_captures <span class="co"># =&gt; {&quot;lang&quot;=&gt;[1],&quot;ver&quot;=&gt;[2],&quot;review&quot;=&gt;[3]}</span>
<span class="co">###########################</span>
<span class="co"># Ruby 1.9 only</span>
<span class="kw">if</span> <span class="ot">/(?&lt;lang&gt;\w+) (?&lt;ver&gt;\d+\.(\d+)+) (?&lt;review&gt;\w+)/</span> =~ <span class="st">&quot;Ruby 1.9 rules!&quot;</span>
  lang     <span class="co"># =&gt; &quot;Ruby&quot;</span>
  ver      <span class="co"># =&gt; &quot;1.9&quot;</span>
  review   <span class="co"># =&gt; &quot;rules&quot;</span>
<span class="kw">end</span>
<span class="co">###########################</span>
<span class="kw">if</span> data = pattern.match(text)  <span class="co"># Or: data = text.match(pattern)</span>
  handle_match(data)
<span class="kw">end</span>
<span class="co">###########################</span>
pattern.match(text) {|data| handle_match(data) }</code></pre></div>
<h4 id="pattern-matching-with-strings">9.2.4.2 Pattern matching with strings</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="st">&quot;ruby123&quot;</span>[<span class="ot">/\d+/</span>]              <span class="co"># &quot;123&quot;</span>
<span class="st">&quot;ruby123&quot;</span>[<span class="ot">/([a-z]+)(\d+)/</span>,<span class="dv">1</span>]  <span class="co"># &quot;ruby&quot;</span>
<span class="st">&quot;ruby123&quot;</span>[<span class="ot">/([a-z]+)(\d+)/</span>,<span class="dv">2</span>]  <span class="co"># &quot;123&quot;</span>
<span class="co">###########################</span>
r = <span class="st">&quot;ruby123&quot;</span>
r.slice!(<span class="ot">/\d+/</span>)  <span class="co"># Returns &quot;123&quot;, changes r to &quot;ruby&quot;</span>
<span class="co">###########################</span>
s = <span class="st">&quot;one, two, three&quot;</span>
s.split            <span class="co"># [&quot;one,&quot;,&quot;two,&quot;,&quot;three&quot;]: whitespace delimiter by default</span>
s.split(<span class="st">&quot;, &quot;</span>)      <span class="co"># [&quot;one&quot;,&quot;two&quot;,&quot;three&quot;]: hardcoded delimiter</span>
s.split(<span class="ot">/\s*,\s*/</span>) <span class="co"># [&quot;one&quot;,&quot;two&quot;,&quot;three&quot;]: space is optional around comma</span>
<span class="co">###########################</span>
text = <span class="st">&quot;hello world&quot;</span>
pattern = <span class="ot">/l/</span>
first = text.index(pattern)       <span class="co"># 2: first match starts at char 2</span>
n = <span class="dt">Regexp</span>.last_match.end(<span class="dv">0</span>)      <span class="co"># 3: end position of first match</span>
second = text.index(pattern, n)   <span class="co"># 3: search again from there</span>
last = text.rindex(pattern)       <span class="co"># 9: rindex searches backward from end</span></code></pre></div>
<h4 id="search-and-replace">9.2.4.3 Search and replace</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">phone = gets                    <span class="co"># Read a phone number</span>
phone.sub!(<span class="ot">/#.*$/</span>, <span class="st">&quot;&quot;</span>)          <span class="co"># Delete Ruby-style comments</span>
phone.gsub!(<span class="ot">/\D/</span>, <span class="st">&quot;&quot;</span>)           <span class="co"># Remove anything other than digits</span>
<span class="co">###########################</span>
text.gsub!(<span class="st">&quot;rails&quot;</span>, <span class="st">&quot;Rails&quot;</span>)     <span class="co"># Change &quot;rails&quot; to &quot;Rails&quot; throughout</span>
<span class="co">###########################</span>
text.gsub!(<span class="ot">/\brails\b/</span>, <span class="st">&quot;Rails&quot;</span>) <span class="co"># Capitalize the word &quot;Rails&quot; throughout</span>
<span class="co">###########################</span>
text.gsub(<span class="ot">/\bruby\b/i</span>, <span class="st">&#39;&lt;b&gt;\0&lt;/b&gt;&#39;</span>)
<span class="co">###########################</span>
text.gsub(<span class="ot">/\bruby\b/i</span>, <span class="st">&quot;&lt;b&gt;</span><span class="ot">#{</span><span class="dt">$&amp;</span><span class="ot">}</span><span class="st">&lt;/b&gt;&quot;</span>)
<span class="co">###########################</span>
<span class="co"># Strip pairs of quotes from a string</span>
re = <span class="ot">/(?&lt;quote&gt;[&#39;&quot;])(?&lt;body&gt;[^&#39;&quot;]*)\k&lt;quote&gt;/</span>
puts <span class="st">&quot;These are &#39;quotes&#39;&quot;</span>.gsub(re, <span class="st">&#39;\k&lt;body&gt;&#39;</span>)
<span class="co">###########################</span>
<span class="co"># Use consistent capitalization for the names of programming languages</span>
text = <span class="st">&quot;RUBY Java perl PyThOn&quot;</span>         <span class="co"># Text to modify</span>
lang = <span class="ot">/ruby|java|perl|python/i</span>        <span class="co"># Pattern to match</span>
text.gsub!(lang) {|l| l.capitalize }   <span class="co"># Fix capitalization</span>
<span class="co">###########################</span>
pattern = <span class="ot">/([&#39;&quot;])([^\1]*)\1/</span>   <span class="co"># Single- or double-quoted string</span>
text.gsub!(pattern) <span class="kw">do</span>
  <span class="kw">if</span> (<span class="dt">$1</span> == <span class="st">&#39;&quot;&#39;</span>)   <span class="co"># If it was a double-quoted string</span>
    <span class="st">&quot;&#39;#$2&#39;&quot;</span>        <span class="co"># replace with single-quoted</span>
  <span class="kw">else</span>             <span class="co"># Otherwise, if single-quoted</span>
    <span class="st">&quot;\&quot;#$2\&quot;&quot;</span>      <span class="co"># replace with double-quoted</span>
  <span class="kw">end</span>
<span class="kw">end</span></code></pre></div>
<h4 id="numeric-methods">9.3.1 Numeric Methods</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># General Predicates</span>
<span class="dv">0</span>.zero?        <span class="co"># =&gt; true (is this number zero?)</span>
<span class="fl">1.0</span>.zero?      <span class="co"># =&gt; false</span>
<span class="fl">0.0</span>.nonzero?   <span class="co"># =&gt; nil (works like false)</span>
<span class="dv">1</span>.nonzero?     <span class="co"># =&gt; 1 (works like true)</span>
<span class="dv">1</span>.integer?     <span class="co"># =&gt; true</span>
<span class="fl">1.0</span>.integer?   <span class="co"># =&gt; false</span>
<span class="dv">1</span>.scalar?      <span class="co"># =&gt; false: not a complex number. Ruby 1.9.</span>
<span class="fl">1.0</span>.scalar?    <span class="co"># =&gt; false: not a complex number. Ruby 1.9.</span>
<span class="dt">Complex</span>(<span class="dv">1</span>,<span class="dv">2</span>).scalar? <span class="co"># =&gt; true: a complex number. requires &#39;complex&#39;.</span>

<span class="co"># Integer predicates</span>
<span class="dv">0</span>.even?        <span class="co"># =&gt; true (Ruby 1.9)</span>
<span class="dv">0</span>.odd?         <span class="co"># =&gt; false</span>

<span class="co"># Float predicates</span>
<span class="dt">ZERO</span>, <span class="dt">INF</span>, <span class="dt">NAN</span> = <span class="fl">0.0</span>, <span class="fl">1.0</span>/<span class="fl">0.0</span>, <span class="fl">0.0</span>/<span class="fl">0.0</span>  <span class="co"># Constants for testing</span>

<span class="dt">ZERO</span>.finite?   <span class="co"># =&gt; true: is this number finite?</span>
<span class="dt">INF</span>.finite?    <span class="co"># =&gt; false</span>
<span class="dt">NAN</span>.finite?    <span class="co"># =&gt; false</span>

<span class="dt">ZERO</span>.infinite? <span class="co"># =&gt; nil: is this number infinite? Positive or negative?</span>
<span class="dt">INF</span>.infinite?  <span class="co"># =&gt; 1</span>
-<span class="dt">INF</span>.infinite? <span class="co"># =&gt; -1</span>
<span class="dt">NAN</span>.infinite?  <span class="co"># =&gt; nil</span>

<span class="dt">ZERO</span>.nan?      <span class="co"># =&gt; false: is this number not-a-number?</span>
<span class="dt">INF</span>.nan?       <span class="co"># =&gt; false</span>
<span class="dt">NAN</span>.nan?       <span class="co"># =&gt; true</span>
<span class="co">###########################</span>
<span class="co"># Rounding methods</span>
<span class="fl">1.1</span>.ceil     <span class="co"># =&gt;  2: ceiling: smallest integer &gt;= its argument</span>
-<span class="fl">1.1</span>.ceil    <span class="co"># =&gt; -1: ceiling: smallest integer &gt;= its argument</span>
<span class="fl">1.9</span>.floor    <span class="co"># =&gt;  1: floor: largest integer &lt;= its argument</span>
-<span class="fl">1.9</span>.floor   <span class="co"># =&gt; -2: floor: largest integer &lt;= its argument</span>
<span class="fl">1.1</span>.round    <span class="co"># =&gt;  1: round to nearest integer</span>
<span class="fl">0.5</span>.round    <span class="co"># =&gt;  1: round toward infinity when halfway between integers </span>
-<span class="fl">0.5</span>.round   <span class="co"># =&gt; -1: or round toward negative infinity</span>
<span class="fl">1.1</span>.truncate <span class="co"># =&gt;  1: chop off fractional part: round toward zero</span>
-<span class="fl">1.1</span>.to_i    <span class="co"># =&gt; -1: synonym for truncate</span>
<span class="co">###########################</span>
<span class="co"># Absolute value and sign</span>
-<span class="fl">2.0</span>.abs     <span class="co"># =&gt; 2.0: absolute value</span>
-<span class="fl">2.0</span>&lt;=&gt;<span class="fl">0.0</span>   <span class="co"># =&gt; -1: use &lt;=&gt; operator to compute sign of a number</span>

<span class="co"># Constants</span>
<span class="dt">Float</span>::<span class="dt">MAX</span>     <span class="co"># =&gt; 1.79769313486232e+308: may be platform dependent</span>
<span class="dt">Float</span>::<span class="dt">MIN</span>     <span class="co"># =&gt; 2.2250738585072e-308</span>
<span class="dt">Float</span>::<span class="dt">EPSILON</span> <span class="co"># =&gt; 2.22044604925031e-16: difference between adjacent floats</span></code></pre></div>
<h4 id="the-math-module">9.3.2 The Math Module</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># Constants</span>
<span class="dt">Math</span>::<span class="dt">PI</span>               <span class="co"># =&gt; 3.14159265358979</span>
<span class="dt">Math</span>::<span class="dt">E</span>                <span class="co"># =&gt; 2.71828182845905</span>

<span class="co"># Roots</span>
<span class="dt">Math</span>.sqrt(<span class="fl">25.0</span>)        <span class="co"># =&gt; 5.0: square root</span>
<span class="fl">27.0</span>**(<span class="fl">1.0</span>/<span class="fl">3.0</span>)        <span class="co"># =&gt; 3.0: cube root computed with ** operator</span>

<span class="co"># Logarithms</span>
<span class="dt">Math</span>.log10(<span class="fl">100.0</span>)      <span class="co"># =&gt; 2.0: base-10 logarithm</span>
<span class="dt">Math</span>.log(<span class="dt">Math</span>::<span class="dt">E</span>**<span class="dv">3</span>)   <span class="co"># =&gt; 3.0: natural (base-e) logarithm</span>
<span class="dt">Math</span>.log2(<span class="dv">8</span>)           <span class="co"># =&gt; 3.0: base-2 logarithm. Ruby 1.9 and later.</span>
<span class="dt">Math</span>.log(<span class="dv">16</span>, <span class="dv">4</span>)        <span class="co"># =&gt; 2.0: 2nd arg to log() is the base. Ruby 1.9.</span>
<span class="dt">Math</span>.exp(<span class="dv">2</span>)            <span class="co"># =&gt; 7.38905609893065&quot;: same as Math::E**2</span>

<span class="co"># Trigonometry</span>
include <span class="dt">Math</span>           <span class="co"># Save typing: we can now omit Math prefix.</span>
sin(<span class="dt">PI</span>/<span class="dv">2</span>)              <span class="co"># =&gt; 1.0: sine. Argument is in radians, not degrees.</span>
cos(<span class="dv">0</span>)                 <span class="co"># =&gt; 1.0: cosine.</span>
tan(<span class="dt">PI</span>/<span class="dv">4</span>)              <span class="co"># =&gt; 1.0: tangent.</span>
asin(<span class="fl">1.0</span>)/<span class="dt">PI</span>           <span class="co"># =&gt; 0.5: arcsine. See also acos and atan.</span>
sinh(<span class="dv">0</span>)                <span class="co"># =&gt; 0.0: hyperbolic sine. Also cosh, tanh.</span>
asinh(<span class="fl">1.0</span>)             <span class="co"># =&gt; 0.0: inverse sinh. Also acosh, atanh.</span>

<span class="co"># Convert cartesian point (x,y) to polar coordinates (theta, r)</span>
theta = atan2(y,x)     <span class="co"># Angle between X axis and line (0,0)-(x,y)</span>
r = hypot(x,y)         <span class="co"># Hypotenuse: sqrt(x**2 + y**2)</span>

<span class="co"># Decompose float x into fraction f and exponent e, such that x = f*2**e</span>
f,e = frexp(<span class="fl">1024.0</span>)    <span class="co"># =&gt; [0.5, 11]</span>
x = ldexp(f, e)        <span class="co"># =&gt; 1024: compute x = f*2**e</span>

<span class="co"># Error function</span>
erf(<span class="fl">0.0</span>)               <span class="co"># =&gt; 0.0: error function</span>
erfc(<span class="fl">0.0</span>)              <span class="co"># =&gt; 1.0: 1-erf(x): complementary error function</span></code></pre></div>
<h4 id="decimal-arithmetic">9.3.3 Decimal Arithmetic</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">require <span class="st">&quot;bigdecimal&quot;</span>      <span class="co"># Load standard library</span>
dime = <span class="dt">BigDecimal</span>(<span class="st">&quot;0.1&quot;</span>)  <span class="co"># Pass a string to constructor, not a Float</span>
<span class="dv">4</span>*dime<span class="dv">-3</span>*dime == dime     <span class="co"># true with BigDecimal, but false if we use Float</span>

<span class="co"># Compute monthly interest payments on a mortgage with BigDecimal.</span>
<span class="co"># Use &quot;Banker&#39;s Rounding&quot; mode, and limit computations to 20 digits</span>
<span class="dt">BigDecimal</span>.mode(<span class="dt">BigDecimal</span>::<span class="dt">ROUND_MODE</span>, <span class="dt">BigDecimal</span>::<span class="dt">ROUND_HALF_EVEN</span>)
<span class="dt">BigDecimal</span>.limit(<span class="dv">20</span>)
principal = <span class="dt">BigDecimal</span>(<span class="st">&quot;200000&quot;</span>)  <span class="co"># Always pass strings to constructor</span>
apr = <span class="dt">BigDecimal</span>(<span class="st">&quot;6.5&quot;</span>)           <span class="co"># Annual percentage rate interest</span>
years = <span class="dv">30</span>                        <span class="co"># Term of mortgage in years</span>
payments = years*<span class="dv">12</span>               <span class="co"># 12 monthly payments in a year</span>
interest = apr/<span class="dv">100</span>/<span class="dv">12</span>             <span class="co"># Convert APR to monthly fraction</span>
x = (interest<span class="dv">+1</span>)**payments        <span class="co"># Note exponentiation with BigDecimal</span>
monthly = (principal * interest * x)/(x<span class="dv">-1</span>)  <span class="co"># Compute monthly payment</span>
monthly = monthly.round(<span class="dv">2</span>)        <span class="co"># Round to two decimal places</span>
monthly = monthly.to_s(<span class="st">&quot;f&quot;</span>)       <span class="co"># Convert to human-readable string</span></code></pre></div>
<h4 id="complex-numbers">9.3.4 Complex Numbers</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">require <span class="st">&quot;complex&quot;</span>           <span class="co"># Complex is part of the standard library</span>
c = <span class="dt">Complex</span>(<span class="fl">0.5</span>,-<span class="fl">0.2</span>)       <span class="co"># .5-.2i.  </span>
z = <span class="dt">Complex</span>.new(<span class="fl">0.0</span>, <span class="fl">0.0</span>)   <span class="co"># Complex.new also works, but is not required</span>
<span class="dv">10</span>.times { z = z*z + c }    <span class="co"># Iteration for computing Julia set fractals</span>
magnitude = z.abs           <span class="co"># Magnitude of a complex number</span>
x = <span class="dt">Math</span>.sin(z)             <span class="co"># Trig functions work with Complex numbers</span>
<span class="dt">Math</span>.sqrt(-<span class="fl">1.0</span>).to_s        <span class="co"># =&gt; &quot;1.0i&quot;: square root of -1</span>
<span class="dt">Math</span>.sqrt(-<span class="fl">1.0</span>)==<span class="dt">Complex</span>::<span class="dt">I</span> <span class="co"># =&gt; true</span></code></pre></div>
<h4 id="rational-numbers">9.3.5 Rational Numbers</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">require <span class="st">&quot;rational&quot;</span>           <span class="co"># Load the library</span>
penny = <span class="dt">Rational</span>(<span class="dv">1</span>, <span class="dv">100</span>)     <span class="co"># A penny is 1/100th</span>
require <span class="st">&quot;mathn&quot;</span>              <span class="co"># Makes integer division produce Rational values</span>
nickel = <span class="dv">5</span>/<span class="dv">100</span>
dime = <span class="dv">10</span>/<span class="dv">100</span>
quarter = <span class="dv">1</span>/<span class="dv">4</span>
change = <span class="dv">2</span>*quarter + <span class="dv">3</span>*penny <span class="co"># Rational result: 53/100</span>
(<span class="dv">1</span>/<span class="dv">2</span> * <span class="dv">1</span>/<span class="dv">3</span>).to_s             <span class="co"># &quot;1/6&quot;: mathn prints Rationals as fractions</span></code></pre></div>
<h4 id="vectors-and-matrices">9.3.6 Vectors and Matrices</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">require <span class="st">&quot;matrix&quot;</span>

<span class="co"># Represent the point (1,1) as the vector [1,1]</span>
unit = <span class="dt">Vector</span>[<span class="dv">1</span>,<span class="dv">1</span>]

<span class="co"># The identity transformation matrix</span>
identity = <span class="dt">Matrix</span>.identity(<span class="dv">2</span>)  <span class="co"># 2x2 matrix</span>
identity*unit == unit          <span class="co"># true: no transformation</span>

<span class="co"># This matrix scales a point by sx,sy</span>
sx,sy = <span class="fl">2.0</span>, <span class="fl">3.0</span>;
scale = <span class="dt">Matrix</span>[[sx,<span class="dv">0</span>], [<span class="dv">0</span>, sy]]
scale*unit             <span class="co"># =&gt; [2.0, 3.0]: scaled point</span>

<span class="co"># This matrix rotates counterclockwise around the origin</span>
theta = <span class="dt">Math</span>::<span class="dt">PI</span>/<span class="dv">2</span>     <span class="co"># 90 degrees</span>
rotate = <span class="dt">Matrix</span>[[<span class="dt">Math</span>.cos(theta), -<span class="dt">Math</span>.sin(theta)],
                [<span class="dt">Math</span>.sin(theta),  <span class="dt">Math</span>.cos(theta)]]
rotate*unit            <span class="co"># [-1.0, 1.0]: 90 degree rotation</span>

<span class="co"># Two transformations in one</span>
scale * (rotate*unit)  <span class="co"># [-2.0, 3.0]</span></code></pre></div>
<h4 id="random-numbers">9.3.7 Random Numbers</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">rand       <span class="co"># =&gt; 0.964395196505186</span>
rand       <span class="co"># =&gt; 0.390523655919935</span>
rand(<span class="dv">100</span>)  <span class="co"># =&gt; 81</span>
rand(<span class="dv">100</span>)  <span class="co"># =&gt; 32</span>
<span class="co">###########################</span>
srand(<span class="dv">0</span>)                <span class="co"># Known seed</span>
[rand(<span class="dv">100</span>),rand(<span class="dv">100</span>)]   <span class="co"># =&gt; [44,47]: pseudorandom sequence</span>
srand(<span class="dv">0</span>)                <span class="co"># Reset the seed to repeat the sequence</span>
[rand(<span class="dv">100</span>),rand(<span class="dv">100</span>)]   <span class="co"># =&gt; [44,47]</span></code></pre></div>
<h4 id="dates-and-times">9.4 Dates and Times</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># Creating Time objects</span>
<span class="dt">Time</span>.now        <span class="co"># Returns a time object that represents the current time</span>
<span class="dt">Time</span>.new        <span class="co"># A synonym for Time.now</span>

<span class="dt">Time</span>.local(<span class="dv">2007</span>, <span class="dv">7</span>, <span class="dv">8</span>)          <span class="co"># July 8, 2007</span>
<span class="dt">Time</span>.local(<span class="dv">2007</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>)   <span class="co"># July 8, 2007, 09:10am, local time</span>
<span class="dt">Time</span>.utc(<span class="dv">2007</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>)     <span class="co"># July 8, 2007, 09:10 UTC</span>
<span class="dt">Time</span>.gm(<span class="dv">2007</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>, <span class="dv">11</span>)  <span class="co"># July 8, 2007, 09:10:11 GMT (same as UTC)</span>

<span class="co"># One microsecond before the new millennium began in London</span>
<span class="co"># We&#39;ll use this Time object in many examples below.</span>
t = <span class="dt">Time</span>.utc(<span class="dv">2000</span>, <span class="dv">12</span>, <span class="dv">31</span>, <span class="dv">23</span>, <span class="dv">59</span>, <span class="dv">59</span>, <span class="dv">999999</span>)

<span class="co"># Components of a Time</span>
t.year    <span class="co"># =&gt; 2000</span>
t.month   <span class="co"># =&gt; 12: December</span>
t.day     <span class="co"># =&gt; 31</span>
t.wday    <span class="co"># =&gt; 0: day of week: 0 is Sunday</span>
t.yday    <span class="co"># =&gt; 366: day of year: 2000 was a leap year</span>
t.hour    <span class="co"># =&gt; 23: 24-hour clock</span>
t.min     <span class="co"># =&gt; 59</span>
t.sec     <span class="co"># =&gt; 59</span>
t.usec    <span class="co"># =&gt; 999999: microseconds, not milliseconds</span>
t.zone    <span class="co"># =&gt; &quot;UTC&quot;: timezone name</span>

<span class="co"># Get all components in an array that holds</span>
<span class="co"># [sec,min,hour,day,month,year,wday,yday,isdst,zone]</span>
<span class="co"># Note that we lose microseconds</span>
values = t.to_a    <span class="co"># =&gt; [59, 59, 23, 31, 12, 2000, 0, 366, false, &quot;UTC&quot;]</span>

<span class="co"># Arrays of this form can be passed to Time.local and Time.utc</span>
values[<span class="dv">5</span>] += <span class="dv">1</span>     <span class="co"># Increment the year</span>
<span class="dt">Time</span>.utc(*values)  <span class="co"># =&gt; Mon Dec 31 23:59:59 UTC 2001</span>

<span class="co"># Timezones and daylight savings time</span>
t.zone       <span class="co"># =&gt; &quot;UTC&quot;: return the timezone</span>
t.utc?       <span class="co"># =&gt; true: t is in UTC time zone</span>
t.utc_offset <span class="co"># =&gt; 0: UTC is 0 seconds offset from UTC</span>
t.localtime  <span class="co"># Convert to local timezone. Mutates the Time object!</span>
t.zone       <span class="co"># =&gt; &quot;PST&quot; (or whatever your timezone is)</span>
t.utc?       <span class="co"># =&gt; false</span>
t.utc_offset <span class="co"># =&gt; -28800: 8 hours before UTC</span>
t.gmtime     <span class="co"># Convert back to UTC. Another mutator.</span>
t.getlocal   <span class="co"># Return a new Time object in local zone</span>
t.getutc     <span class="co"># Return a new Time object in UTC</span>
t.isdst      <span class="co"># =&gt; false: UTC does not have DST. Note no ?.</span>
t.getlocal.isdst <span class="co"># =&gt; false: no daylight savings time in winter.</span>

<span class="co"># Weekday predicates: Ruby 1.9</span>
t.sunday?    <span class="co"># =&gt; true</span>
t.monday?    <span class="co"># =&gt; false</span>
t.tuesday?   <span class="co"># etc.</span>

<span class="co"># Formatting Times and Dates</span>
t.to_s       <span class="co"># =&gt; &quot;Sun Dec 31 23:59:59 UTC 2000&quot;: Ruby 1.8</span>
t.to_s       <span class="co"># =&gt; &quot;2000-12-31 23:59:59 UTC&quot;: Ruby 1.9 uses ISO-8601</span>
t.ctime      <span class="co"># =&gt; &quot;Sun Dec 31 23:59:59 2000&quot;: another basic format</span>

<span class="co"># strftime interpolates date and time components into a template string</span>
<span class="co"># Locale-independent formatting</span>
t.strftime(<span class="st">&quot;%Y-%m-%d %H:%M:%S&quot;</span>) <span class="co"># =&gt; &quot;2000-12-31 23:59:59&quot;: ISO-8601 format</span>
t.strftime(<span class="st">&quot;%H:%M&quot;</span>)             <span class="co"># =&gt; &quot;23:59&quot;: 24-hour time</span>
t.strftime(<span class="st">&quot;%I:%M %p&quot;</span>)          <span class="co"># =&gt; &quot;11:59 PM&quot;: 12-hour clock</span>

<span class="co"># Locale-dependent formats</span>
t.strftime(<span class="st">&quot;%A, %B %d&quot;</span>)         <span class="co"># =&gt; &quot;Sunday, December 31&quot;</span>
t.strftime(<span class="st">&quot;%a, %b %d %y&quot;</span>)      <span class="co"># =&gt; &quot;Sun, Dec 31 00&quot;: 2-digit year</span>
t.strftime(<span class="st">&quot;%x&quot;</span>)                <span class="co"># =&gt; &quot;12/31/00&quot;: locale-dependent format</span>
t.strftime(<span class="st">&quot;%X&quot;</span>)                <span class="co"># =&gt; &quot;23:59:59&quot;</span>
t.strftime(<span class="st">&quot;%c&quot;</span>)                <span class="co"># same as ctime</span>

<span class="co"># Parsing Times and Dates</span>
require <span class="st">&#39;parsedate&#39;</span>    <span class="co"># A versatile date/time parsing library</span>
include <span class="dt">ParseDate</span>      <span class="co"># Include parsedate() as a global function</span>
datestring = <span class="st">&quot;2001-01-01&quot;</span>
values = parsedate(datestring)  <span class="co"># [2001, 1, 1, nil, nil, nil, nil, nil]</span>
t = <span class="dt">Time</span>.local(*values)         <span class="co"># =&gt; Mon Jan 01 00:00:00 -0800 2001</span>
s = t.ctime                     <span class="co"># =&gt; &quot;Mon Jan  1 00:00:00 2001&quot;</span>
<span class="dt">Time</span>.local(*parsedate(s))==t    <span class="co"># =&gt; true</span>

s = <span class="st">&quot;2001-01-01 00:00:00-0500&quot;</span>  <span class="co"># midnight in New York</span>
v = parsedate(s)                <span class="co"># =&gt; [2001, 1, 1, 0, 0, 0, &quot;-0500&quot;, nil]</span>
t = <span class="dt">Time</span>.local(*v)              <span class="co"># Loses time zone information!</span>

<span class="co"># Time arithmetic</span>
now = <span class="dt">Time</span>.now          <span class="co"># Current time</span>
past = now - <span class="dv">10</span>         <span class="co"># 10 seconds ago. Time - number =&gt; Time</span>
future = now + <span class="dv">10</span>       <span class="co"># 10 seconds from now Time + number =&gt; Time</span>
future - now            <span class="co"># =&gt; 10  Time - Time =&gt; number of seconds</span>

<span class="co"># Time comparisons</span>
past &lt;=&gt; future         <span class="co"># =&gt; -1</span>
past &lt; future           <span class="co"># =&gt; true</span>
now &gt;= future           <span class="co"># =&gt; false</span>
now == now              <span class="co"># =&gt; true</span>

<span class="co"># Helper methods for working with time units other than seconds</span>
<span class="kw">class</span> <span class="dt">Numeric</span>
  <span class="co"># Convert time intervals to seconds</span>
  <span class="kw">def</span> milliseconds; <span class="dv">self</span>/<span class="fl">1000.0</span>; <span class="kw">end</span>
  <span class="kw">def</span> seconds; <span class="dv">self</span>; <span class="kw">end</span>
  <span class="kw">def</span> minutes; <span class="dv">self</span>*<span class="dv">60</span>; <span class="kw">end</span>
  <span class="kw">def</span> hours; <span class="dv">self</span>*<span class="dv">60</span>*<span class="dv">60</span>; <span class="kw">end</span>
  <span class="kw">def</span> days; <span class="dv">self</span>*<span class="dv">60</span>*<span class="dv">60</span>*<span class="dv">24</span>; <span class="kw">end</span>
  <span class="kw">def</span> weeks; <span class="dv">self</span>*<span class="dv">60</span>*<span class="dv">60</span>*<span class="dv">24</span>*<span class="dv">7</span>; <span class="kw">end</span>

  <span class="co"># Convert seconds to other intervals</span>
  <span class="kw">def</span> to_milliseconds; <span class="dv">self</span>*<span class="dv">1000</span>; <span class="kw">end</span>
  <span class="kw">def</span> to_seconds; <span class="dv">self</span>; <span class="kw">end</span>
  <span class="kw">def</span> to_minutes; <span class="dv">self</span>/<span class="fl">60.0</span>; <span class="kw">end</span>
  <span class="kw">def</span> to_hours; <span class="dv">self</span>/(<span class="dv">60</span>*<span class="fl">60.0</span>); <span class="kw">end</span>
  <span class="kw">def</span> to_days; <span class="dv">self</span>/(<span class="dv">60</span>*<span class="dv">60</span>*<span class="fl">24.0</span>); <span class="kw">end</span>
  <span class="kw">def</span> to_weeks; <span class="dv">self</span>/(<span class="dv">60</span>*<span class="dv">60</span>*<span class="dv">24</span>*<span class="fl">7.0</span>); <span class="kw">end</span>
<span class="kw">end</span>

expires = now + <span class="dv">10</span>.days     <span class="co"># 10 days from now</span>
expires - now               <span class="co"># =&gt; 864000.0 seconds</span>
(expires - now).to_hours    <span class="co"># =&gt; 240.0 hours</span>

<span class="co"># Time represented internally as seconds since the (platform-dependent) epoch</span>
t = <span class="dt">Time</span>.now.to_i    <span class="co"># =&gt; 1184036194 seconds since epoch</span>
<span class="dt">Time</span>.at(t)           <span class="co"># =&gt; seconds since epoch to Time object</span>
t = <span class="dt">Time</span>.now.to_f    <span class="co"># =&gt; 1184036322.90872: includes 908720 microseconds</span>
<span class="dt">Time</span>.at(<span class="dv">0</span>)           <span class="co"># =&gt; Wed Dec 31 16:00:00 -0800 1969: epoch in local time</span></code></pre></div>
<h4 id="iterating-and-converting-collections">9.5.1.1 Iterating and converting collections</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">(<span class="dv">5</span>..<span class="dv">7</span>).each {|x| print x }                 <span class="co"># Prints &quot;567&quot;</span>
(<span class="dv">5</span>..<span class="dv">7</span>).each_with_index {|x,i| print x,i }  <span class="co"># Prints &quot;506172&quot;</span>
<span class="co">###########################</span>
(<span class="dv">1</span>..<span class="dv">10</span>).each_slice(<span class="dv">4</span>) {|x| print x } <span class="co"># Prints &quot;[1,2,3,4][5,6,7,8][9,10]&quot;</span>
<span class="co">###########################</span>
(<span class="dv">1</span>..<span class="dv">5</span>).each_cons(<span class="dv">3</span>) {|x| print x }    <span class="co"># Prints &quot;[1,2,3][2,3,4][3,4,5]&quot;</span>
<span class="co">###########################</span>
data = [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]                        <span class="co"># An enumerable collection</span>
roots = data.collect {|x| <span class="dt">Math</span>.sqrt(x)} <span class="co"># Collect roots of our data</span>
words =<span class="ot"> %w[</span><span class="st">hello world</span><span class="ot">]</span>                 <span class="co"># Another collection</span>
upper = words.map {|x| x.upcase }       <span class="co"># Map to uppercase</span>
<span class="co">###########################</span>
(<span class="dv">1</span>..<span class="dv">3</span>).zip([<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]) {|x| print x.inspect } <span class="co"># Prints &quot;[1,4][2,5][3,6]&quot;</span>
(<span class="dv">1</span>..<span class="dv">3</span>).zip([<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>],[<span class="dv">7</span>,<span class="dv">8</span>]) {|x| print x}    <span class="co"># Prints &quot;14725836&quot;</span>
(<span class="dv">1</span>..<span class="dv">3</span>).zip(<span class="st">&#39;a&#39;</span>..<span class="st">&#39;c&#39;</span>) {|x,y| print x,y }    <span class="co"># Prints &quot;1a2b3c&quot;</span>
<span class="co">###########################</span>
(<span class="dv">1</span>..<span class="dv">3</span>).to_a       <span class="co"># =&gt; [1,2,3]</span>
(<span class="dv">1</span>..<span class="dv">3</span>).entries    <span class="co"># =&gt; [1,2,3]</span>
<span class="co">###########################</span>
require <span class="st">&#39;set&#39;</span>
(<span class="dv">1</span>..<span class="dv">3</span>).to_set     <span class="co"># =&gt; #&lt;Set: {1, 2, 3}&gt;</span></code></pre></div>
<h4 id="enumerators-and-external-iterators">9.5.1.2 Enumerators and external iterators</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">e = [<span class="dv">1</span>..<span class="dv">10</span>].to_enum              <span class="co"># Uses Range.each</span>
e = <span class="st">&quot;test&quot;</span>.enum_for(<span class="st">:each_byte</span>)  <span class="co"># Uses String.each_byte</span>
e = <span class="st">&quot;test&quot;</span>.each_byte             <span class="co"># Uses String.each_byte</span>
<span class="co">###########################</span>
<span class="st">&quot;Ruby&quot;</span>.each_char.max       <span class="co"># =&gt; &quot;y&quot;; Enumerable method of Enumerator</span>
iter = <span class="st">&quot;Ruby&quot;</span>.each_char    <span class="co"># Create an Enumerator</span>
loop { print iter.next }   <span class="co"># Prints &quot;Ruby&quot;; use it as external iterator</span>
print iter.next            <span class="co"># Prints &quot;R&quot;: iterator restarts automatically</span>
iter.rewind                <span class="co"># Force it to restart now</span>
print iter.next            <span class="co"># Prints &quot;R&quot; again</span>
<span class="co">###########################</span>
<span class="co"># print &quot;0:R\n1:u\n2:b\n3:y\n&quot;</span>
<span class="st">&quot;Ruby&quot;</span>.each_char.with_index.each {|c,i| puts <span class="st">&quot;</span><span class="ot">#{</span>i<span class="ot">}</span><span class="st">:</span><span class="ot">#{</span>c<span class="ot">}</span><span class="st">&quot;</span> }</code></pre></div>
<h4 id="sorting-collections">9.5.1.3 Sorting collections</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">w = <span class="dt">Set</span>[<span class="st">&#39;apple&#39;</span>,<span class="st">&#39;Beet&#39;</span>,<span class="st">&#39;carrot&#39;</span>]  <span class="co"># A set of words to sort</span>
w.sort                         <span class="co"># [&#39;Beet&#39;,&#39;apple&#39;,&#39;carrot&#39;]: alphabetical</span>
w.sort {|a,b| b&lt;=&gt;a }          <span class="co"># [&#39;carrot&#39;,&#39;apple&#39;,&#39;Beet&#39;]: reverse</span>
w.sort {|a,b| a.casecmp(b) }   <span class="co"># [&#39;apple&#39;,&#39;Beet&#39;,&#39;carrot&#39;]: ignore case</span>
w.sort {|a,b| b.size&lt;=&gt;a.size} <span class="co"># [&#39;carrot&#39;,&#39;apple&#39;,&#39;Beet&#39;]: reverse length</span>
<span class="co">###########################</span>
<span class="co"># Case-insensitive sort</span>
words = [<span class="st">&#39;carrot&#39;</span>, <span class="st">&#39;Beet&#39;</span>, <span class="st">&#39;apple&#39;</span>]
words.sort_by {|x| x.downcase}       <span class="co"># =&gt; [&#39;apple&#39;, &#39;Beet&#39;, &#39;carrot&#39;]</span></code></pre></div>
<h4 id="searching-collections">9.5.1.4 Searching collections</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">primes = <span class="dt">Set</span>[<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>]
primes.include? <span class="dv">2</span>        <span class="co"># =&gt; true</span>
primes.member? <span class="dv">1</span>         <span class="co"># =&gt; false</span>
<span class="co">###########################</span>
<span class="co"># Find the first subarray that includes the number 1</span>
data = [[<span class="dv">1</span>,<span class="dv">2</span>], [<span class="dv">0</span>,<span class="dv">1</span>], [<span class="dv">7</span>,<span class="dv">8</span>]]
data.find {|x| x.include? <span class="dv">1</span>}     <span class="co"># =&gt; [1,2]</span>
data.detect {|x| x.include? <span class="dv">3</span>}   <span class="co"># =&gt; nil: no such element</span>
<span class="co">###########################</span>
data.find_index {|x| x.include? <span class="dv">1</span>} <span class="co"># =&gt; 0: the first element matches</span>
data.find_index {|x| x.include? <span class="dv">3</span>} <span class="co"># =&gt; nil: no such element</span></code></pre></div>
<h4 id="selecting-subcollections">9.5.1.5 Selecting subcollections</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">(<span class="dv">1</span>..<span class="dv">8</span>).select {|x| x%<span class="dv">2</span>==<span class="dv">0</span>}    <span class="co"># =&gt; [2,4,6,8]: select even elements</span>
(<span class="dv">1</span>..<span class="dv">8</span>).find_all {|x| x%<span class="dv">2</span>==<span class="dv">1</span>}  <span class="co"># =&gt; [1,3,5,7]: find all odd elements</span>
<span class="co">###########################</span>
primes = [<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>]
primes.reject {|x| x%<span class="dv">2</span>==<span class="dv">0</span>}  <span class="co"># =&gt; [3,5,7]: reject the even ones</span>
<span class="co">###########################</span>
(<span class="dv">1</span>..<span class="dv">8</span>).partition {|x| x%<span class="dv">2</span>==<span class="dv">0</span>}  <span class="co"># =&gt; [[2, 4, 6, 8], [1, 3, 5, 7]]</span>
<span class="co">###########################</span>
<span class="co"># Group programming languages by their first letter</span>
langs =<span class="ot"> %w[</span><span class="st"> java perl python ruby </span><span class="ot">]</span>
groups = langs.group_by {|lang| lang[<span class="dv">0</span>] }
groups <span class="co"># =&gt; {&quot;j&quot;=&gt;[&quot;java&quot;], &quot;p&quot;=&gt;[&quot;perl&quot;, &quot;python&quot;], &quot;r&quot;=&gt;[&quot;ruby&quot;]}</span>
<span class="co">###########################</span>
langs =<span class="ot"> %w[</span><span class="st"> java perl python ruby </span><span class="ot">]</span>
langs.grep(<span class="ot">/^p/</span>)                    <span class="co"># =&gt; [perl, python]: start with &#39;p&#39;</span>
langs.grep(<span class="ot">/^p/</span>) {|x| x.capitalize} <span class="co"># =&gt; [Perl, Python]: fix caps</span>
data = [<span class="dv">1</span>, <span class="dv">17</span>, <span class="fl">3.0</span>, <span class="dv">4</span>]
ints = data.grep(<span class="dt">Integer</span>)           <span class="co"># =&gt; [1, 17, 4]: only integers</span>
small = ints.grep(<span class="dv">0</span>..<span class="dv">9</span>)             <span class="co"># [1,4]: only in range</span>
<span class="co">###########################</span>
p (<span class="dv">1</span>..<span class="dv">5</span>).first(<span class="dv">2</span>)      <span class="co"># =&gt; [1,2]</span>
p (<span class="dv">1</span>..<span class="dv">5</span>).take(<span class="dv">3</span>)       <span class="co"># =&gt; [1,2,3]</span>
p (<span class="dv">1</span>..<span class="dv">5</span>).drop(<span class="dv">3</span>)       <span class="co"># =&gt; [4,5]</span>
<span class="co">###########################</span>
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">nil</span>,<span class="dv">4</span>].take_while {|x| x }  <span class="co"># =&gt; [1,2,3]: take until nil</span>
[<span class="dv">nil</span>, <span class="dv">1</span>, <span class="dv">2</span>].drop_while {|x| !x }   <span class="co"># =&gt; [1,2]: drop leading nils</span></code></pre></div>
<h4 id="reducing-collections">9.5.1.6 Reducing collections</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">[<span class="dv">10</span>, <span class="dv">100</span>, <span class="dv">1</span>].min    <span class="co"># =&gt; 1</span>
[<span class="st">&#39;a&#39;</span>,<span class="st">&#39;c&#39;</span>,<span class="st">&#39;b&#39;</span>].max   <span class="co"># =&gt; &#39;c&#39;</span>
[<span class="dv">10</span>, <span class="st">&#39;a&#39;</span>, []].min   <span class="co"># =&gt; ArgumentError: elements not comparable</span>
<span class="co">###########################</span>
langs =<span class="ot"> %w[</span><span class="st">java perl python ruby</span><span class="ot">]</span>    <span class="co"># Which has the longest name?</span>
langs.max {|a,b| a.size &lt;=&gt; b.size } <span class="co"># =&gt; &quot;python&quot;: block compares 2</span>
langs.max_by {|word| word.length }   <span class="co"># =&gt; &quot;python&quot;: Ruby 1.9 only</span>
<span class="co">###########################</span>
(<span class="dv">1</span>..<span class="dv">100</span>).minmax                   <span class="co"># =&gt; [1,100] min, max as numbers</span>
(<span class="dv">1</span>..<span class="dv">100</span>).minmax_by {|n| n.to_s }  <span class="co"># =&gt; [1,99]  min, max as strings</span>
<span class="co">###########################</span>
c = -<span class="dv">2</span>..<span class="dv">2</span>
c.all? {|x| x&gt;<span class="dv">0</span>}    <span class="co"># =&gt; false: not all values are &gt; 0</span>
c.any? {|x| x&gt;<span class="dv">0</span>}    <span class="co"># =&gt; true: some values are &gt; 0</span>
c.none? {|x| x&gt;<span class="dv">2</span>}   <span class="co"># =&gt; true: no values are &gt; 2</span>
c.one? {|x| x&gt;<span class="dv">0</span>}    <span class="co"># =&gt; false: more than one value is &gt; 0</span>
c.one? {|x| x&gt;<span class="dv">2</span>}    <span class="co"># =&gt; false: no values are &gt; 2</span>
c.one? {|x| x==<span class="dv">2</span>}   <span class="co"># =&gt; true: one value == 2</span>
[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>].all?      <span class="co"># =&gt; true: no values are nil or false</span>
[<span class="dv">nil</span>, <span class="dv">false</span>].any?   <span class="co"># =&gt; false: no true values</span>
[].none?            <span class="co"># =&gt; true: no non-false, non-nil values    </span>
<span class="co">###########################</span>
a = [<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">8</span>]
a.count(<span class="dv">1</span>)                <span class="co"># =&gt; 2: two elements equal 1</span>
a.count {|x| x % <span class="dv">2</span> == <span class="dv">1</span>}  <span class="co"># =&gt; 4: four elements are odd</span>
<span class="co">###########################</span>
<span class="co"># How many negative numbers?</span>
(-<span class="dv">2</span>..<span class="dv">10</span>).inject(<span class="dv">0</span>) {|num, x| x&lt;<span class="dv">0</span> ? num<span class="dv">+1</span> : num }  <span class="co"># =&gt; 2</span>

<span class="co"># Sum of word lengths</span>
<span class="ot">%w[</span><span class="st">pea queue are</span><span class="ot">]</span>.inject(<span class="dv">0</span>) {|total, word| total + word.length }  <span class="co"># =&gt; 11</span>
<span class="co">###########################</span>
sum = (<span class="dv">1</span>..<span class="dv">5</span>).inject {|total,x| total + x}  <span class="co"># =&gt; 15</span>
prod = (<span class="dv">1</span>..<span class="dv">5</span>).inject {|total,x| total * x} <span class="co"># =&gt; 120</span>
max = [<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>].inject {|m,x| m&gt;x ? m : x}   <span class="co"># =&gt; 3</span>
[<span class="dv">1</span>].inject {|total,x| total + x}           <span class="co"># =&gt; 1: block never called</span>
<span class="co">###########################</span>
sum = (<span class="dv">1</span>..<span class="dv">5</span>).reduce(:+)                    <span class="co"># =&gt; 15</span>
prod = (<span class="dv">1</span>..<span class="dv">5</span>).reduce(:*)                   <span class="co"># =&gt; 120</span>
letters = (<span class="st">&#39;a&#39;</span>..<span class="st">&#39;e&#39;</span>).reduce(<span class="st">&quot;-&quot;</span>, <span class="st">:concat</span>)  <span class="co"># =&gt; &quot;-abcde&quot;</span></code></pre></div>
<h4 id="creating-arrays">9.5.2.1 Creating arrays</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]             <span class="co"># Basic array literal</span>
[]                  <span class="co"># An empty array</span>
[]                  <span class="co"># Arrays are mutable: this empty array is different</span>
<span class="ot">%w[</span><span class="st">a b c</span><span class="ot">]</span>           <span class="co"># =&gt; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]: array of words</span>
<span class="dt">Array</span>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]        <span class="co"># =&gt; [1,2,3]: just like an array literal</span>

<span class="co"># Creating arrays with the new() method</span>
empty = <span class="dt">Array</span>.new             <span class="co"># []: returns a new empty array</span>
nils = <span class="dt">Array</span>.new(<span class="dv">3</span>)           <span class="co"># [nil, nil, nil]: three nil elements</span>
copy = <span class="dt">Array</span>.new(nils)        <span class="co"># Make a new copy of an existing array</span>
zeros = <span class="dt">Array</span>.new(<span class="dv">4</span>, <span class="dv">0</span>)       <span class="co"># [0, 0, 0, 0]: four 0 elements</span>
count = <span class="dt">Array</span>.new(<span class="dv">3</span>){|i| i<span class="dv">+1</span>} <span class="co"># [1,2,3]: three elements computed by block</span>

<span class="co"># Be careful with repeated objects</span>
a=<span class="dt">Array</span>.new(<span class="dv">3</span>,<span class="st">&#39;a&#39;</span>)  <span class="co"># =&gt; [&#39;a&#39;,&#39;a&#39;,&#39;a&#39;]: three references to the same string</span>
a[<span class="dv">0</span>].upcase!        <span class="co"># Capitalize the first element of the array</span>
a                   <span class="co"># =&gt; [&#39;A&#39;,&#39;A&#39;,&#39;A&#39;]: they are all the same string!</span>
a=<span class="dt">Array</span>.new(<span class="dv">3</span>){<span class="st">&#39;b&#39;</span>} <span class="co"># =&gt; [&#39;b&#39;,&#39;b&#39;,&#39;b&#39;]: three distinct string objects</span>
a[<span class="dv">0</span>].upcase!;       <span class="co"># Capitalize the first one</span>
a                   <span class="co"># =&gt; [&#39;B&#39;,&#39;b&#39;,&#39;b&#39;]: the others are still lowercase</span></code></pre></div>
<h4 id="array-size-and-elements">9.5.2.2 Array size and elements</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># Array length</span>
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>].length     <span class="co"># =&gt; 3</span>
[].size            <span class="co"># =&gt; 0: synonym for length</span>
[].empty?          <span class="co"># =&gt; true</span>
[<span class="dv">nil</span>].empty?       <span class="co"># =&gt; false</span>
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">nil</span>].nitems   <span class="co"># =&gt; 2: number of non-nil elements          </span>
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>].nitems {|x| x&gt;<span class="dv">2</span>} <span class="co"># =&gt; 1: # of elts matching block (Ruby 1.9)</span>

<span class="co"># Indexing single elements</span>
a =<span class="ot"> %w[</span><span class="st">a b c d</span><span class="ot">]</span>    <span class="co"># =&gt; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span>
a[<span class="dv">0</span>]               <span class="co"># =&gt; &#39;a&#39;: first element</span>
a[-<span class="dv">1</span>]              <span class="co"># =&gt; &#39;d&#39;: last element</span>
a[a.size<span class="dv">-1</span>]        <span class="co"># =&gt; &#39;d&#39;: last element</span>
a[-a.size<span class="dv">-1</span>]       <span class="co"># =&gt; &#39;a&#39;: first element</span>
a[<span class="dv">5</span>]               <span class="co"># =&gt; nil: no such element</span>
a[-<span class="dv">5</span>]              <span class="co"># =&gt; nil: no such element</span>
a.at(<span class="dv">2</span>)            <span class="co"># =&gt; &#39;c&#39;: just like [] for single integer argument</span>
a.fetch(<span class="dv">1</span>)         <span class="co"># =&gt; &#39;b&#39;: also like [] and at</span>
a.fetch(-<span class="dv">1</span>)        <span class="co"># =&gt; &#39;d&#39;: works with negative args</span>
a.fetch(<span class="dv">5</span>)         <span class="co"># =&gt; IndexError!: does not allow out-of-bounds</span>
a.fetch(-<span class="dv">5</span>)        <span class="co"># =&gt; IndexError!: does not allow out-of-bounds</span>
a.fetch(<span class="dv">5</span>, <span class="dv">0</span>)      <span class="co"># =&gt; 0: return 2nd arg when out-of-bounds</span>
a.fetch(<span class="dv">5</span>){|x|x*x} <span class="co"># =&gt; 25: compute value when out-of-bounds</span>
a.first            <span class="co"># =&gt; &#39;a&#39;: the first element</span>
a.last             <span class="co"># =&gt; &#39;d&#39;: the last element</span>
a.choice           <span class="co"># Ruby 1.9: return one element at random</span>

<span class="co"># Indexing subarrays</span>
a[<span class="dv">0</span>,<span class="dv">2</span>]             <span class="co"># =&gt; [&#39;a&#39;,&#39;b&#39;]: two elements, starting at 0</span>
a[<span class="dv">0</span>..<span class="dv">2</span>]            <span class="co"># =&gt; [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]: elements with index in range</span>
a[<span class="dv">0</span>...<span class="dv">2</span>]           <span class="co"># =&gt; [&#39;a&#39;,&#39;b&#39;]: three dots instead of two</span>
a[<span class="dv">1</span>,<span class="dv">1</span>]             <span class="co"># =&gt; [&#39;b&#39;]: single element, as an array</span>
a[-<span class="dv">2</span>,<span class="dv">2</span>]            <span class="co"># =&gt; [&#39;c&#39;,&#39;d&#39;]: last two elements</span>
a[<span class="dv">4</span>,<span class="dv">2</span>]             <span class="co"># =&gt; []: empty array right at the end </span>
a[<span class="dv">5</span>,<span class="dv">1</span>]             <span class="co"># =&gt; nil: nothing beyond that</span>
a.slice(<span class="dv">0</span>..<span class="dv">1</span>)      <span class="co"># =&gt; [&#39;a&#39;,&#39;b&#39;]: slice is synonym for []</span>
a.first(<span class="dv">3</span>)         <span class="co"># =&gt; [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]: first three elements</span>
a.last(<span class="dv">1</span>)          <span class="co"># =&gt; [&#39;d&#39;]: last element as an array</span>

<span class="co"># Extracting arbitrary values</span>
a.values_at(<span class="dv">0</span>,<span class="dv">2</span>)         <span class="co"># =&gt; [&#39;a&#39;,&#39;c&#39;]</span>
a.values_at(<span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>)  <span class="co"># =&gt; [nil, &#39;d&#39;,&#39;c&#39;,&#39;b&#39;]</span>
a.values_at(<span class="dv">0</span>, <span class="dv">2</span>..<span class="dv">3</span>, -<span class="dv">1</span>) <span class="co"># =&gt; [&#39;a&#39;,&#39;c&#39;,&#39;d&#39;,&#39;d&#39;]</span>
a.values_at(<span class="dv">0</span>..<span class="dv">2</span>,<span class="dv">1</span>..<span class="dv">3</span>)   <span class="co"># =&gt; [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]</span></code></pre></div>
<h4 id="altering-array-elements">9.5.2.3 Altering array elements</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">a = [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]        <span class="co"># Start with this array</span>
<span class="co"># Changing the value of elements</span>
a[<span class="dv">0</span>] = <span class="dv">0</span>           <span class="co"># Alter an existing element: a is [0,2,3]</span>
a[-<span class="dv">1</span>] = <span class="dv">4</span>          <span class="co"># Alter the last element: a is [0,2,4]</span>
a[<span class="dv">1</span>] = <span class="dv">nil</span>         <span class="co"># Set the 2nd element to nil: a is [0,nil,4]</span>

<span class="co"># Appending to an array</span>
a = [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]        <span class="co"># Start over with this array</span>
a[<span class="dv">3</span>] = <span class="dv">4</span>           <span class="co"># Add a fourth element to it: a is [1,2,3,4]</span>
a[<span class="dv">5</span>] = <span class="dv">6</span>           <span class="co"># We can skip elements: a is [1,2,3,4,nil,6]</span>
a &lt;&lt; <span class="dv">7</span>             <span class="co"># =&gt; [1,2,3,4,nil,6,7]</span>
a &lt;&lt; <span class="dv">8</span> &lt;&lt; <span class="dv">9</span>        <span class="co"># =&gt; [1,2,3,4,nil,6,7,8,9] operator is chainable</span>
a = [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]        <span class="co"># Start over with short array</span>
a + a              <span class="co"># =&gt; [1,2,3,1,2,3]: + concatenates into new array</span>
a.concat([<span class="dv">4</span>,<span class="dv">5</span>])    <span class="co"># =&gt; [1,2,3,4,5]: alter a in place: note no !</span>

<span class="co"># Inserting elements with insert</span>
a = [<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>]
a.insert(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>)  <span class="co"># a now holds [&#39;a&#39;,1,2,&#39;b&#39;,&#39;c&#39;]. Like a[1,0] = [1,2]</span>

<span class="co"># Removing (and returning) individual elements by index</span>
a = [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]
a.delete_at(<span class="dv">4</span>)     <span class="co"># =&gt; 5: a is now [1,2,3,4,6]</span>
a.delete_at(-<span class="dv">1</span>)    <span class="co"># =&gt; 6: a is now [1,2,3,4]</span>
a.delete_at(<span class="dv">4</span>)     <span class="co"># =&gt; nil: a is unchanged</span>

<span class="co"># Removing elements by value</span>
a.delete(<span class="dv">4</span>)        <span class="co"># =&gt; 4: a is [1,2,3]</span>
a[<span class="dv">1</span>] = <span class="dv">1</span>           <span class="co"># a is now [1,1,3]</span>
a.delete(<span class="dv">1</span>)        <span class="co"># =&gt; 1: a is now [3]: both 1s removed</span>
a = [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
a.delete_if {|x| x%<span class="dv">2</span>==<span class="dv">1</span>} <span class="co"># Remove odd values: a is now [2]</span>
a.reject! {|x| x%<span class="dv">2</span>==<span class="dv">0</span>}   <span class="co"># Like delete_if: a is now []</span>
 
<span class="co"># Removing elements and subarrays with slice!</span>
a = [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>]
a.slice!(<span class="dv">0</span>)        <span class="co"># =&gt; 1: remove element 0: a is [2,3,4,5,6,7,8]</span>
a.slice!(-<span class="dv">1</span>,<span class="dv">1</span>)     <span class="co"># =&gt; [8]: remove subarray at end: a is [2,3,4,5,6,7]</span>
a.slice!(<span class="dv">2</span>..<span class="dv">3</span>)     <span class="co"># =&gt; [4,5]: works with ranges: a is [2,3,6,7]</span>
a.slice!(<span class="dv">4</span>,<span class="dv">2</span>)      <span class="co"># =&gt; []: empty array just past end: a unchanged</span>
a.slice!(<span class="dv">5</span>,<span class="dv">2</span>)      <span class="co"># =&gt; nil: a now holds [2,3,6,7,nil]!</span>

<span class="co"># Replacing subarrays with []=</span>
<span class="co"># To delete, assign an empty array</span>
<span class="co"># To insert, assign to a zero-width slice</span>
a = (<span class="st">&#39;a&#39;</span>..<span class="st">&#39;e&#39;</span>).to_a    <span class="co"># =&gt; [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]</span>
a[<span class="dv">0</span>,<span class="dv">2</span>] = [<span class="st">&#39;A&#39;</span>,<span class="st">&#39;B&#39;</span>]     <span class="co"># a now holds [&#39;A&#39;, &#39;B&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</span>
a[<span class="dv">2</span>...<span class="dv">5</span>]=[<span class="st">&#39;C&#39;</span>,<span class="st">&#39;D&#39;</span>,<span class="st">&#39;E&#39;</span>] <span class="co"># a now holds [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;]</span>
a[<span class="dv">0</span>,<span class="dv">0</span>] = [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]       <span class="co"># Insert elements at the beginning of a</span>
a[<span class="dv">0</span>..<span class="dv">2</span>] = []           <span class="co"># Delete those elements</span>
a[-<span class="dv">1</span>,<span class="dv">1</span>] = [<span class="st">&#39;Z&#39;</span>]        <span class="co"># Replace last element with another</span>
a[-<span class="dv">1</span>,<span class="dv">1</span>] = <span class="st">&#39;Z&#39;</span>          <span class="co"># For single elements, the array is optional</span>
a[<span class="dv">1</span>,<span class="dv">4</span>] = <span class="dv">nil</span>           <span class="co"># Ruby 1.9: a now holds [&#39;A&#39;,nil]</span>
                       <span class="co"># Ruby 1.8: a now holds [&#39;A&#39;]: nil works like []</span>

<span class="co"># Other methods</span>
a = [<span class="dv">4</span>,<span class="dv">5</span>]
a.replace([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>])     <span class="co"># a now holds [1,2,3]: a copy of its argument</span>
a.fill(<span class="dv">0</span>)              <span class="co"># a now holds [0,0,0]</span>
a.fill(<span class="dv">nil</span>,<span class="dv">1</span>,<span class="dv">3</span>)        <span class="co"># a now holds [0,nil,nil,nil]</span>
a.fill(<span class="st">&#39;a&#39;</span>,<span class="dv">2</span>..<span class="dv">4</span>)       <span class="co"># a now holds [0,nil,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;]</span>
a[<span class="dv">3</span>].upcase!           <span class="co"># a now holds [0,nil,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;]</span>
a.fill(<span class="dv">2</span>..<span class="dv">4</span>) { <span class="st">&#39;b&#39;</span> }   <span class="co"># a now holds [0,nil,&#39;b&#39;,&#39;b&#39;,&#39;b&#39;]</span>
a[<span class="dv">3</span>].upcase!           <span class="co"># a now holds [0,nil,&#39;b&#39;,&#39;B&#39;,&#39;b&#39;]</span>
a.compact              <span class="co"># =&gt; [0,&#39;b&#39;,&#39;B&#39;,&#39;b&#39;]: copy with nils removed</span>
a.compact!             <span class="co"># Remove nils in place: a now holds [0,&#39;b&#39;,&#39;B&#39;,&#39;b&#39;]</span>
a.clear                <span class="co"># a now holds []</span></code></pre></div>
<h4 id="iterating-searching-and-sorting-arrays">9.5.2.4 Iterating, searching, and sorting arrays</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">a = [<span class="st">&#39;a&#39;</span>,<span class="st">&#39;b&#39;</span>,<span class="st">&#39;c&#39;</span>]
a.each {| elt| print elt }         <span class="co"># The basic each iterator prints &quot;abc&quot;</span>
a.reverse_each {|e| print e}       <span class="co"># Array-specific: prints &quot;cba&quot; </span>
a.cycle {|e| print e }             <span class="co"># Ruby 1.9: prints &quot;abcabcabc...&quot; forever</span>
a.each_index {|i| print i}         <span class="co"># Array-specific: prints &quot;012&quot;</span>
a.each_with_index{|e,i| print e,i} <span class="co"># Enumerable: prints &quot;a0b1c2&quot;</span>
a.map {|x| x.upcase}               <span class="co"># Enumerable: returns [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;]</span>
a.map! {|x| x.upcase}              <span class="co"># Array-specific: alters a in place</span>
a.collect! {|x| x.downcase!}       <span class="co"># collect! is synonym for map!</span>

<span class="co"># Searching methods</span>
a =<span class="ot"> %w[</span><span class="st">h e l l o</span><span class="ot">]</span>
a.include?(<span class="st">&#39;e&#39;</span>)                    <span class="co"># =&gt; true</span>
a.include?(<span class="st">&#39;w&#39;</span>)                    <span class="co"># =&gt; false</span>
a.index(<span class="st">&#39;l&#39;</span>)                       <span class="co"># =&gt; 2: index of first match</span>
a.index(<span class="st">&#39;L&#39;</span>)                       <span class="co"># =&gt; nil: no match found</span>
a.rindex(<span class="st">&#39;l&#39;</span>)                      <span class="co"># =&gt; 3: search backwards</span>
a.index {|c| c =~ <span class="ot">/[aeiou]/</span>}       <span class="co"># =&gt; 1: index of first vowel. Ruby 1.9.</span>
a.rindex {|c| c =~ <span class="ot">/[aeiou]/</span>}      <span class="co"># =&gt; 4: index of last vowel. Ruby 1.9.</span>

<span class="co"># Sorting</span>
a.sort     <span class="co"># =&gt; %w[e h l l o]: copy a and sort the copy</span>
a.sort!    <span class="co"># Sort in place: a now holds [&#39;e&#39;,&#39;h&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;]</span>
a = [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]               <span class="co"># A new array to sort into evens and odds</span>
a.sort! {|a,b| a%<span class="dv">2</span> &lt;=&gt; b%<span class="dv">2</span>}   <span class="co"># Compare elements modulo 2</span>

<span class="co"># Shuffling arrays: the opposite of sorting; Ruby 1.9 only</span>
a = [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]     <span class="co"># Start ordered</span>
puts a.shuffle  <span class="co"># Shuffle randomly. E.g.: [3,1,2]. Also shuffle!</span></code></pre></div>
<h4 id="array-comparison">9.5.2.5 Array comparison</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">[<span class="dv">1</span>,<span class="dv">2</span>] &lt;=&gt; [<span class="dv">4</span>,<span class="dv">5</span>]      <span class="co"># =&gt; -1 because 1 &lt; 4</span>
[<span class="dv">1</span>,<span class="dv">2</span>] &lt;=&gt; [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>]    <span class="co"># =&gt; +1 because 1 &gt; 0</span>
[<span class="dv">1</span>,<span class="dv">2</span>] &lt;=&gt; [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]    <span class="co"># =&gt; -1 because first array is shorter</span>
[<span class="dv">1</span>,<span class="dv">2</span>] &lt;=&gt; [<span class="dv">1</span>,<span class="dv">2</span>]      <span class="co"># =&gt; 0: they are equal</span>
[<span class="dv">1</span>,<span class="dv">2</span>] &lt;=&gt; []         <span class="co"># =&gt; +1 [] always less than a nonempty array</span></code></pre></div>
<h4 id="arrays-as-stacks-and-queues">9.5.2.6 Arrays as stacks and queues</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">a = []
a.push(<span class="dv">1</span>)     <span class="co"># =&gt; [1]: a is now [1]</span>
a.push(<span class="dv">2</span>,<span class="dv">3</span>)   <span class="co"># =&gt; [1,2,3]: a is now [1,2,3]</span>
a.pop         <span class="co"># =&gt; 3: a is now [1,2]</span>
a.pop         <span class="co"># =&gt; 2: a is now [1]</span>
a.pop         <span class="co"># =&gt; 1: a is now []</span>
a.pop         <span class="co"># =&gt; nil: a is still []</span>
<span class="co">###########################</span>
a = []
a.push(<span class="dv">1</span>)     <span class="co"># =&gt; [1]: a is [1]</span>
a.push(<span class="dv">2</span>)     <span class="co"># =&gt; [1,2]: a is [1,2]</span>
a.shift       <span class="co"># =&gt; 1: a is [2]</span>
a.push(<span class="dv">3</span>)     <span class="co"># =&gt; [2,3]: a is [2,3]</span>
a.shift       <span class="co"># =&gt; 2: a is [3]</span>
a.shift       <span class="co"># =&gt; 3: a is []</span>
a.shift       <span class="co"># =&gt; nil: a is []</span></code></pre></div>
<h4 id="arrays-as-sets">9.5.2.7 Arrays as sets</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>] &amp; [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]           <span class="co"># =&gt; [1,3]: set intersection</span>
[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>] &amp; [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]         <span class="co"># =&gt; [1,3]: duplicates removed</span>
[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>] | [<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>]           <span class="co"># =&gt; [1,3,5,2,4,6]: set union</span>
[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">5</span>] | [<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">6</span>]       <span class="co"># =&gt; [1,3,5,2,4,6]: duplicates removed</span>
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] - [<span class="dv">2</span>,<span class="dv">3</span>]             <span class="co"># =&gt; [1]: set difference</span>
[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">3</span>] - [<span class="dv">2</span>, <span class="dv">3</span>]      <span class="co"># =&gt; [1,1]: not all duplicates removed</span>

small = <span class="dv">0</span>..<span class="dv">10</span>.to_a          <span class="co"># A set of small numbers</span>
even = <span class="dv">0</span>..<span class="dv">50</span>.map {|x| x*<span class="dv">2</span>}  <span class="co"># A set of even numbers</span>
smalleven = small &amp; even    <span class="co"># Set intersection</span>
smalleven.include?(<span class="dv">8</span>)       <span class="co"># =&gt; true: test for set membership</span>

[<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">nil</span>, <span class="dv">nil</span>].uniq       <span class="co"># =&gt; [1, nil]: remove dups. Also uniq!</span>
<span class="co">###########################</span>
a = [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]

<span class="co"># Iterate all possible 2-element subarrays (order matters)</span>
a.permutation(<span class="dv">2</span>) {|x| print x }  <span class="co"># Prints &quot;[1,2][1,3][2,1][2,3][3,1][3,2]&quot;</span>

<span class="co"># Iterate all possible 2-element subsets (order does not matter)</span>
a.combination(<span class="dv">2</span>) {|x| print x }  <span class="co"># Prints &quot;[1, 2][1, 3][2, 3]&quot;</span>

<span class="co"># Return the Cartesian product of the two sets</span>
a.product([<span class="st">&#39;a&#39;</span>,<span class="st">&#39;b&#39;</span>])       <span class="co"># =&gt; [[1,&quot;a&quot;],[1,&quot;b&quot;],[2,&quot;a&quot;],[2,&quot;b&quot;],[3,&quot;a&quot;],[3,&quot;b&quot;]]</span>
[<span class="dv">1</span>,<span class="dv">2</span>].product([<span class="dv">3</span>,<span class="dv">4</span>],[<span class="dv">5</span>,<span class="dv">6</span>]) <span class="co"># =&gt; [[1,3,5],[1,3,6],[1,4,5],[1,4,6], etc... ] </span></code></pre></div>
<h4 id="associative-array-methods">9.5.2.8 Associative array methods</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">[[key1, value1], [key2, value2], [key3, value3], ...]
<span class="co">###########################</span>
h = { <span class="st">:a</span> =&gt; <span class="dv">1</span>, <span class="st">:b</span> =&gt; <span class="dv">2</span>}   <span class="co"># Start with a hash</span>
a = h.to_a                <span class="co"># =&gt; [[:b,2], [:a,1]]: associative array</span>
a.assoc(<span class="st">:a</span>)               <span class="co"># =&gt; [:a,1]: subarray for key :a</span>
a.assoc(<span class="st">:b</span>).last          <span class="co"># =&gt; 2: value for key :b</span>
a.rassoc(<span class="dv">1</span>)               <span class="co"># =&gt; [:a,1]: subarray for value 1</span>
a.rassoc(<span class="dv">2</span>).first         <span class="co"># =&gt; :b: key for value 2</span>
a.assoc(<span class="st">:c</span>)               <span class="co"># =&gt; nil</span>
a.transpose               <span class="co"># =&gt; [[:a, :b], [1, 2]]: swap rows and cols</span></code></pre></div>
<h4 id="miscellaneous-array-methods">9.5.2.9 Miscellaneous array methods</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># Conversion to strings</span>
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>].join              <span class="co"># =&gt; &quot;123&quot;: convert elements to string and join</span>
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>].join(<span class="st">&quot;, &quot;</span>)        <span class="co"># =&gt; &quot;1, 2, 3&quot;: optional delimiter</span>
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>].to_s              <span class="co"># =&gt; &quot;[1, 2, 3]&quot; in Ruby 1.9</span>
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>].to_s              <span class="co"># =&gt; &quot;123&quot; in Ruby 1.8</span>
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>].inspect           <span class="co"># =&gt; &quot;[1, 2, 3]&quot;: better for debugging in 1.8</span>

<span class="co"># Binary conversion with pack. See also String.unpack.</span>
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>].pack(<span class="st">&quot;CCCC&quot;</span>)    <span class="co"># =&gt; &quot;\001\002\003\004&quot;</span>
[<span class="dv">1</span>,<span class="dv">2</span>].pack(<span class="st">&#39;s2&#39;</span>)          <span class="co"># =&gt; &quot;\001\000\002\000&quot;</span>
[<span class="dv">1234</span>].pack(<span class="st">&quot;i&quot;</span>)          <span class="co"># =&gt; &quot;\322\004\000\000&quot;</span>

<span class="co"># Other methods</span>
[<span class="dv">0</span>,<span class="dv">1</span>]*<span class="dv">3</span>                   <span class="co"># =&gt; [0,1,0,1,0,1]: * operator repeats</span>
[<span class="dv">1</span>, [<span class="dv">2</span>, [<span class="dv">3</span>]]].flatten     <span class="co"># =&gt; [1,2,3]: recursively flatten; also flatten!</span>
[<span class="dv">1</span>, [<span class="dv">2</span>, [<span class="dv">3</span>]]].flatten(<span class="dv">1</span>)  <span class="co"># =&gt; [1,2,[3]]: specify # of levels; Ruby 1.9</span>
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>].reverse           <span class="co"># =&gt; [3,2,1]: also reverse!</span>
a=[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>].zip([<span class="st">:a</span>,<span class="st">:b</span>,<span class="st">:c</span>]) <span class="co"># =&gt; [[1,:a],[2,:b],[3,:c]]: Enumerable method</span>
a.transpose               <span class="co"># =&gt; [[1,2,3],[:a,:b,:c]]: swap rows/cols</span></code></pre></div>
<h4 id="creating-hashes">9.5.3.1 Creating hashes</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">{ <span class="st">:one</span> =&gt; <span class="dv">1</span>, <span class="st">:two</span> =&gt; <span class="dv">2</span> }  <span class="co"># Basic hash literal syntax</span>
{ <span class="st">:one</span>, <span class="dv">1</span>, <span class="st">:two</span>, <span class="dv">2</span> }      <span class="co"># Same, with deprecated Ruby 1.8 syntax</span>
{ <span class="st">one: </span><span class="dv">1</span>, <span class="st">two: </span><span class="dv">2</span> }        <span class="co"># Same, Ruby 1.9 syntax. Keys are symbols.</span>
{}                        <span class="co"># A new, empty, Hash object</span>
<span class="dt">Hash</span>.new                  <span class="co"># =&gt; {}: creates empty hash</span>
<span class="dt">Hash</span>[<span class="st">:one</span>, <span class="dv">1</span>, <span class="st">:two</span>, <span class="dv">2</span>]    <span class="co"># =&gt; {one:1, two:2}</span>
<span class="co">###########################</span>
puts <span class="st">:a=</span>&gt;<span class="dv">1</span>, <span class="st">:b=</span>&gt;<span class="dv">2</span>   <span class="co"># Curly braces omitted in invocation</span>
puts a:<span class="dv">1</span>, b:<span class="dv">2</span>       <span class="co"># Ruby 1.9 syntax works too</span></code></pre></div>
<h4 id="indexing-hashes-and-testing-membership">9.5.3.2 Indexing hashes and testing membership</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">h = { <span class="st">:one</span> =&gt; <span class="dv">1</span>, <span class="st">:two</span> =&gt; <span class="dv">2</span> }
h[<span class="st">:one</span>]       <span class="co"># =&gt; 1: find value associated with a key</span>
h[<span class="st">:three</span>]     <span class="co"># =&gt; nil: the key does not exist in the hash</span>
h.assoc <span class="st">:one</span>  <span class="co"># =&gt; [:one, 1]: find key/value pair. Ruby 1.9.</span>

h.index <span class="dv">1</span>     <span class="co"># =&gt; :one: search for key associated with a value</span>
h.index <span class="dv">4</span>     <span class="co"># =&gt; nil: no mapping to this value exists</span>
h.rassoc <span class="dv">2</span>    <span class="co"># =&gt; [:two, 2]: key/value pair matching value. Ruby 1.9.</span>
<span class="co">###########################</span>
h = { <span class="st">:a</span> =&gt; <span class="dv">1</span>, <span class="st">:b</span> =&gt; <span class="dv">2</span> }
<span class="co"># Checking for the presence of keys in a hash: fast</span>
h.key?(<span class="st">:a</span>)       <span class="co"># true: :a is a key in h</span>
h.has_key?(<span class="st">:b</span>)   <span class="co"># true: has_key? is a synonym for key?</span>
h.include?(<span class="st">:c</span>)   <span class="co"># false: include? is another synonym</span>
h.member?(<span class="st">:d</span>)    <span class="co"># false: member? is yet another synonym</span>

<span class="co"># Checking for the presence of values: slow</span>
h.value?(<span class="dv">1</span>)      <span class="co"># true: 1 is a value in h</span>
h.has_value?(<span class="dv">3</span>)  <span class="co"># false: has_value? is a synonym for value?</span>
<span class="co">###########################</span>
h = { <span class="st">:a</span> =&gt; <span class="dv">1</span>, <span class="st">:b</span> =&gt; <span class="dv">2</span> }
h.fetch(<span class="st">:a</span>)      <span class="co"># =&gt; 1: works like [] for existing keys</span>
h.fetch(<span class="st">:c</span>)      <span class="co"># Raises IndexError for nonexistent key</span>
h.fetch(<span class="st">:c</span>, <span class="dv">33</span>)  <span class="co"># =&gt; 33: uses specified value if key is not found</span>
h.fetch(<span class="st">:c</span>) {|k| k.to_s } <span class="co"># =&gt; &quot;c&quot;: calls block if key not found</span>
<span class="co">###########################</span>
h = { <span class="st">:a</span> =&gt; <span class="dv">1</span>, <span class="st">:b</span> =&gt; <span class="dv">2</span>, <span class="st">:c</span> =&gt; <span class="dv">3</span> }
h.values_at(<span class="st">:c</span>)         <span class="co"># =&gt; [3]: values returned in an array</span>
h.values_at(<span class="st">:a</span>, <span class="st">:b</span>)     <span class="co"># =&gt; [1, 2]: pass any # of args</span>
h.values_at(<span class="st">:d</span>, <span class="st">:d</span>, <span class="st">:a</span>) <span class="co"># =&gt; [nil, nil, 1]</span>
<span class="co">###########################</span>
h = { <span class="st">:a</span> =&gt; <span class="dv">1</span>, <span class="st">:b</span> =&gt; <span class="dv">2</span>, <span class="st">:c</span> =&gt; <span class="dv">3</span> }
h.select {|k,v| v % <span class="dv">2</span> == <span class="dv">0</span> } <span class="co"># =&gt; [:b,2] Ruby 1.8</span>
h.select {|k,v| v % <span class="dv">2</span> == <span class="dv">0</span> } <span class="co"># =&gt; {:b=&gt;2} Ruby 1.9</span></code></pre></div>
<h4 id="storing-keys-and-values-in-a-hash">9.5.3.3 Storing keys and values in a hash</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">h = {}        <span class="co"># Start with an empty hash</span>
h[<span class="st">:a</span>] = <span class="dv">1</span>     <span class="co"># Map :a=&gt;1.  h is now {:a=&gt;1}</span>
h.store(<span class="st">:b</span>,<span class="dv">2</span>) <span class="co"># More verbose: h is now {:a=&gt;1, :b=&gt;2}</span>
<span class="co">###########################</span>
<span class="co"># Replace all of the pairs in h with those from another hash</span>
h.replace({<span class="dv">1</span>=&gt;<span class="st">:a</span>, <span class="dv">2</span>=&gt;;b}  <span class="co"># h is now equal to the argument hash</span>
<span class="co">###########################</span>
<span class="co"># Merge hashes h and j into new hash k.  </span>
<span class="co"># If h and j share keys, use values from j</span>
k = h.merge(j)
{<span class="st">:a=</span>&gt;<span class="dv">1</span>,<span class="st">:b=</span>&gt;<span class="dv">2</span>}.merge(<span class="st">:a=</span>&gt;<span class="dv">3</span>,<span class="st">:c=</span>&gt;<span class="dv">3</span>)  <span class="co"># =&gt; {:a=&gt;3,:b=&gt;2,:c=&gt;3}</span>
h.merge!(j)   <span class="co"># Modifies h in place.</span>

<span class="co"># If there is a block, use it to decide which value to use</span>
h.merge!(j) {|key,h,j| h }      <span class="co"># Use value from h</span>
h.merge(j) {|key,h,j| (h+j)/<span class="dv">2</span> } <span class="co"># Use average of two values</span>

<span class="co"># update is a synonym for merge!</span>
h = {a:<span class="dv">1</span>,b:<span class="dv">2</span>}     <span class="co"># Using Ruby 1.9 syntax and omitting braces</span>
h.update(b:<span class="dv">4</span>,c:<span class="dv">9</span>) {|key,old,new| old }  <span class="co"># h is now {a:1, b:2, c:9}</span>
h.update(b:<span class="dv">4</span>,c:<span class="dv">9</span>) <span class="co"># h is now {a:1, b:4, c:9}</span></code></pre></div>
<h4 id="removing-hash-entries">9.5.3.4 Removing hash entries</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">h = {<span class="st">:a=</span>&gt;<span class="dv">1</span>, <span class="st">:b=</span>&gt;<span class="dv">2</span>}
h[<span class="st">:a</span>] = <span class="dv">nil</span>      <span class="co"># h now holds {:a=&gt; nil, :b=&gt;2 }</span>
h.include? <span class="st">:a</span>    <span class="co"># =&gt; true</span>
h.delete <span class="st">:b</span>      <span class="co"># =&gt; 2: returns deleted value: h now holds {:a=&gt;nil}</span>
h.include? <span class="st">:b</span>    <span class="co"># =&gt; false</span>
h.delete <span class="st">:b</span>      <span class="co"># =&gt; nil: key not found</span>
<span class="co"># Invoke block if key not found</span>
h.delete(<span class="st">:b</span>) {|k| raise <span class="dt">IndexError</span>, k.to_s } <span class="co"># IndexError!</span>
<span class="co">###########################</span>
h = {<span class="st">:a=</span>&gt;<span class="dv">1</span>, <span class="st">:b=</span>&gt;<span class="dv">2</span>, <span class="st">:c=</span>&gt;<span class="dv">3</span>, <span class="st">:d=</span>&gt;<span class="st">&quot;four&quot;</span>}
h.reject! {|k,v| v.is_a? <span class="dt">String</span> }  <span class="co"># =&gt; {:a=&gt;1, :b=&gt;2, :c=&gt;3 }</span>
h.delete_if {|k,v| k.to_s &lt; <span class="st">&#39;b&#39;</span> }  <span class="co"># =&gt; {:b=&gt;2, :c=&gt;3 }</span>
h.reject! {|k,v| k.to_s &lt; <span class="st">&#39;b&#39;</span> }    <span class="co"># =&gt; nil: no change</span>
h.delete_if {|k,v| k.to_s &lt; <span class="st">&#39;b&#39;</span> }  <span class="co"># =&gt; {:b=&gt;2, :c=&gt;3 }: unchanged hash</span>
h.reject {|k,v| <span class="dv">true</span> }             <span class="co"># =&gt; {}: h is unchanged</span>
<span class="co">###########################</span>
h.clear    <span class="co"># h is now {}</span></code></pre></div>
<h4 id="arrays-from-hashes">9.5.3.5 Arrays from hashes</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">h = { <span class="st">:a=</span>&gt;<span class="dv">1</span>, <span class="st">:b=</span>&gt;<span class="dv">2</span>, <span class="st">:c=</span>&gt;<span class="dv">3</span> }
<span class="co"># Size of hash: number of key/value pairs</span>
h.length     <span class="co"># =&gt; 3</span>
h.size       <span class="co"># =&gt; 3: size is a synonym for length</span>
h.empty?     <span class="co"># =&gt; false</span>
{}.empty?    <span class="co"># =&gt; true</span>

h.keys       <span class="co"># =&gt; [:b, :c, :a]: array of keys</span>
h.values     <span class="co"># =&gt; [2,3,1]: array of values</span>
h.to_a       <span class="co"># =&gt; [[:b,2],[:c,3],[:a,1]]: array of pairs</span>
h.flatten    <span class="co"># =&gt; [:b, 2, :c, 3, :a, 1]: flattened array. Ruby 1.9</span>
h.sort       <span class="co"># =&gt; [[:a,1],[:b,2],[:c,3]]: sorted array of pairs</span>
h.sort {|a,b| a[<span class="dv">1</span>]&lt;=&gt;b[<span class="dv">1</span>] } <span class="co"># Sort pairs by value instead of key</span></code></pre></div>
<h4 id="hash-iterators">9.5.3.6 Hash iterators</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">h = { <span class="st">:a=</span>&gt;<span class="dv">1</span>, <span class="st">:b=</span>&gt;<span class="dv">2</span>, <span class="st">:c=</span>&gt;<span class="dv">3</span> }

<span class="co"># The each() iterator iterates [key,value] pairs</span>
h.each {|pair| print pair }    <span class="co"># Prints &quot;[:a, 1][:b, 2][:c, 3]&quot;</span>

<span class="co"># It also works with two block arguments</span>
h.each <span class="kw">do</span> |key, value|                
  print <span class="st">&quot;</span><span class="ot">#{</span>key<span class="ot">}</span><span class="st">:</span><span class="ot">#{</span>value<span class="ot">}</span><span class="st"> &quot;</span>     <span class="co"># Prints &quot;a:1 b:2 c:3&quot; </span>
<span class="kw">end</span>

<span class="co"># Iterate over keys or values or both</span>
h.each_key {|k| print k }      <span class="co"># Prints &quot;abc&quot;</span>
h.each_value {|v| print v }    <span class="co"># Prints &quot;123&quot;</span>
h.each_pair {|k,v| print k,v } <span class="co"># Prints &quot;a1b2c3&quot;. Like each</span>
<span class="co">###########################</span>
h = { <span class="st">:a=</span>&gt; <span class="dv">1</span>, <span class="st">:b=</span>&gt;<span class="dv">2</span> }
print h.shift[<span class="dv">1</span>] <span class="kw">while</span> <span class="kw">not</span> h.empty?   <span class="co"># Prints &quot;12&quot;</span></code></pre></div>
<h4 id="default-values">9.5.3.7 Default values</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">empty = {}
empty[<span class="st">&quot;one&quot;</span>]   <span class="co"># nil</span>
<span class="co">###########################</span>
empty = <span class="dt">Hash</span>.new(-<span class="dv">1</span>)   <span class="co"># Specify a default value when creating hash</span>
empty[<span class="st">&quot;one&quot;</span>]           <span class="co"># =&gt; -1</span>
empty.default = -<span class="dv">2</span>     <span class="co"># Change the default value to something else</span>
empty[<span class="st">&quot;two&quot;</span>]           <span class="co"># =&gt; -2</span>
empty.default          <span class="co"># =&gt; -2: return the default value</span>
<span class="co">###########################</span>
<span class="co"># If the key is not defined, return the successor of the key.</span>
plus1 = <span class="dt">Hash</span>.new {|hash, key| key.succ }
plus1[<span class="dv">1</span>]      <span class="co"># 2</span>
plus1[<span class="st">&quot;one&quot;</span>]  <span class="co"># &quot;onf&quot;: see String.succ</span>
plus1.default_proc  <span class="co"># Returns the Proc that computes defaults</span>
plus1.default(<span class="dv">10</span>)   <span class="co"># =&gt; 11: default returned for key 10</span>
<span class="co">###########################</span>
<span class="co"># This lazily initialized hash maps integers to their factorials</span>
fact = <span class="dt">Hash</span>.new {|h,k| h[k] <span class="kw">= if</span> k &gt; <span class="dv">1</span>: k*h[k<span class="dv">-1</span>] <span class="kw">else</span> <span class="dv">1</span> <span class="kw">end</span> }
fact      <span class="co"># {}: it starts off empty</span>
fact[<span class="dv">4</span>]   <span class="co"># 24: 4! is 24</span>
fact      <span class="co"># {1=&gt;1, 2=&gt;2, 3=&gt;6, 4=&gt;24}: the hash now has entries</span>
<span class="co">###########################</span>
fact.fetch(<span class="dv">5</span>)   <span class="co"># IndexError: key not found</span></code></pre></div>
<h4 id="hashcodes-key-equality-and-mutable-keys">9.5.3.8 Hashcodes, key equality, and mutable keys</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">key = {<span class="st">:a=</span>&gt;<span class="dv">1</span>}      <span class="co"># This hash will be a key in another hash!</span>
h = { key =&gt; <span class="dv">2</span> }   <span class="co"># This hash has a mutable key</span>
h[key]             <span class="co"># =&gt; 2: get value associated with key</span>
key.clear          <span class="co"># Mutate the key</span>
h[key]             <span class="co"># =&gt; nil: no value found for mutated key</span>
h.rehash           <span class="co"># Fix up the hash after mutation</span>
h[key]             <span class="co"># =&gt; 2: now the value is found again</span></code></pre></div>
<h4 id="miscellaneous-hash-methods">9.5.3.9 Miscellaneous hash methods</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">h = {<span class="st">:a=</span>&gt;<span class="dv">1</span>, <span class="st">:b=</span>&gt;<span class="dv">2</span>}
h.invert        <span class="co"># =&gt; {1=&gt;:a, 2=&gt;:b}: swap keys and values</span>
<span class="co">###########################</span>
{<span class="st">:a=</span>&gt;<span class="dv">1</span>, <span class="st">:b=</span>&gt;<span class="dv">2</span>}.to_s    <span class="co"># =&gt; &quot;a1b2&quot; in Ruby 1.8; &quot;{:a=&gt;1, :b=&gt;2}&quot; in 1.9</span>
{<span class="st">:a=</span>&gt;<span class="dv">1</span>, <span class="st">:b=</span>&gt;<span class="dv">2</span>}.inspect <span class="co"># =&gt; &quot;{:a=&gt;1, :b=&gt;2}&quot; for both versions</span></code></pre></div>
<h4 id="sets">9.5.4 Sets</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">require <span class="st">&#39;set&#39;</span></code></pre></div>
<h4 id="creating-sets">9.5.4.1 Creating sets</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">(<span class="dv">1</span>..<span class="dv">5</span>).to_set              <span class="co"># =&gt; #&lt;Set: {5, 1, 2, 3, 4}&gt;</span>
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>].to_set             <span class="co"># =&gt; #&lt;Set: {1, 2, 3}&gt;</span>
<span class="co">###########################</span>
<span class="dt">Set</span>.new(<span class="dv">1</span>..<span class="dv">5</span>)              <span class="co"># =&gt; #&lt;Set: {5, 1, 2, 3, 4}&gt;</span>
<span class="dt">Set</span>.new([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>])           <span class="co"># =&gt; #&lt;Set: {1, 2, 3}&gt;</span>
<span class="dt">Set</span>.new([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]) {|x| x<span class="dv">+1</span>} <span class="co"># =&gt; #&lt;Set: {2, 3, 4}&gt;</span>
<span class="co">###########################</span>
<span class="dt">Set</span>[<span class="st">&quot;cow&quot;</span>, <span class="st">&quot;pig&quot;</span>, <span class="st">&quot;hen&quot;</span>]   <span class="co"># =&gt; #&lt;Set: {&quot;cow&quot;, &quot;pig&quot;, &quot;hen&quot;}&gt;</span></code></pre></div>
<h4 id="testing-comparing-and-combining-sets">9.5.4.2 Testing, comparing, and combining Sets</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">s = <span class="dt">Set</span>.new(<span class="dv">1</span>..<span class="dv">3</span>)   <span class="co"># =&gt; #&lt;Set: {1, 2, 3}&gt;  </span>
s.include? <span class="dv">1</span>        <span class="co"># =&gt; true</span>
s.member? <span class="dv">0</span>         <span class="co"># =&gt; false: member? is a synonym</span>
<span class="co">###########################</span>
s = <span class="dt">Set</span>[<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>]
t = <span class="dt">Set</span>[<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>]
s.subset? t            <span class="co"># =&gt; true</span>
t.subset? s            <span class="co"># =&gt; false</span>
s.proper_subset? t     <span class="co"># =&gt; true</span>
t.superset? s          <span class="co"># =&gt; true</span>
t.proper_superset? s   <span class="co"># =&gt; true</span>
s.subset? s            <span class="co"># =&gt; true</span>
s.proper_subset? s     <span class="co"># =&gt; false</span>
<span class="co">###########################</span>
s = <span class="dt">Set</span>[<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>]
s.length               <span class="co"># =&gt; 3</span>
s.size                 <span class="co"># =&gt; 3: a synonym for length</span>
s.empty?               <span class="co"># =&gt; false</span>
<span class="dt">Set</span>.new.empty?         <span class="co"># =&gt; true</span>
<span class="co">###########################</span>
<span class="co"># Here are two simple sets</span>
primes = <span class="dt">Set</span>[<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>]
odds = <span class="dt">Set</span>[<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">9</span>]

<span class="co"># The intersection is the set of values that appear in both</span>
primes &amp; odds             <span class="co"># =&gt; #&lt;Set: {5, 7, 3}&gt;</span>
primes.intersection(odds) <span class="co"># this is an explicitly named alias</span>

<span class="co"># The union is the set of values that appear in either</span>
primes | odds             <span class="co"># =&gt; #&lt;Set: {5, 1, 7, 2, 3, 9}&gt;</span>
primes.union(odds)        <span class="co"># an explicitly named alias</span>

<span class="co"># a-b: is the elements of a except for those also in b</span>
primes-odds               <span class="co"># =&gt; #&lt;Set: {2}&gt;</span>
odds-primes               <span class="co"># =&gt; #&lt;Set: {1, 9}&gt;</span>
primes.difference(odds)   <span class="co"># A named method alias</span>

<span class="co"># a^b is the set of values that appear in one set but not both: (a|b)-(a&amp;b)</span>
primes ^ odds             <span class="co"># =&gt; #&lt;Set: {1, 2, 9}&gt;</span></code></pre></div>
<h4 id="adding-and-deleting-set-elements">9.5.4.3 Adding and deleting set elements</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">s = <span class="dt">Set</span>[]              <span class="co"># start with an empty set</span>
s &lt;&lt; <span class="dv">1</span>                 <span class="co"># =&gt; #&lt;Set: {1}&gt;</span>
s.add <span class="dv">2</span>                <span class="co"># =&gt; #&lt;Set: {1, 2}&gt;: add is a synonym for &lt;&lt;</span>
s &lt;&lt; <span class="dv">3</span> &lt;&lt; <span class="dv">4</span> &lt;&lt; <span class="dv">5</span>       <span class="co"># =&gt; #&lt;Set: {5, 1, 2, 3, 4}&gt;: can be chained</span>
s.add <span class="dv">3</span>                <span class="co"># =&gt; #&lt;Set: {5, 1, 2, 3, 4}&gt;: value unchanged</span>
s.add? <span class="dv">6</span>               <span class="co"># =&gt; #&lt;Set: {5, 6, 1, 2, 3, 4}&gt;</span>
s.add? <span class="dv">3</span>               <span class="co"># =&gt; nil: the set was not changed </span>
<span class="co">###########################</span>
s = (<span class="dv">1</span>..<span class="dv">3</span>).to_set   <span class="co"># =&gt; #&lt;Set: {1, 2, 3}&gt;</span>
s.merge(<span class="dv">2</span>..<span class="dv">5</span>)       <span class="co"># =&gt; #&lt;Set: {5, 1, 2, 3, 4}&gt;</span>
<span class="co">###########################</span>
s = (<span class="dv">1</span>..<span class="dv">3</span>).to_set   <span class="co"># =&gt; #&lt;Set: {1, 2, 3}&gt;</span>
s.delete <span class="dv">1</span>          <span class="co"># =&gt; #&lt;Set: {2, 3}&gt;</span>
s.delete <span class="dv">1</span>          <span class="co"># =&gt; #&lt;Set: {2, 3}&gt;: unchanged</span>
s.delete? <span class="dv">1</span>         <span class="co"># =&gt; nil: returns nil when no change</span>
s.delete? <span class="dv">2</span>         <span class="co"># =&gt; #&lt;Set: {3}&gt;: otherwise returns set</span>
<span class="co">###########################</span>
s = (<span class="dv">1</span>..<span class="dv">3</span>).to_set   <span class="co"># =&gt; #&lt;Set: {1, 2, 3}&gt;</span>
s.subtract(<span class="dv">2</span>..<span class="dv">10</span>)   <span class="co"># =&gt; #&lt;Set: {1}&gt;</span>
<span class="co">###########################</span>
primes = <span class="dt">Set</span>[<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>]       <span class="co"># set of prime numbers</span>
primes.delete_if {|x| x%<span class="dv">2</span>==<span class="dv">1</span>}  <span class="co"># =&gt; #&lt;Set: {2}&gt;: remove odds</span>
primes.delete_if {|x| x%<span class="dv">2</span>==<span class="dv">1</span>}  <span class="co"># =&gt; #&lt;Set: {2}&gt;: unchanged</span>
primes.reject! {|x| x%<span class="dv">2</span>==<span class="dv">1</span>}    <span class="co"># =&gt; nil: unchanged</span>

<span class="co"># Do an in-place intersection like this:</span>
s = (<span class="dv">1</span>..<span class="dv">5</span>).to_set
t = (<span class="dv">4</span>..<span class="dv">8</span>).to_set
s.reject! {|x| <span class="kw">not</span> t.include? x}  <span class="co"># =&gt; #&lt;Set: {5, 4}&gt;</span>
<span class="co">###########################</span>
s = <span class="dt">Set</span>.new(<span class="dv">1</span>..<span class="dv">3</span>) <span class="co"># Initial set</span>
s.replace(<span class="dv">3</span>..<span class="dv">4</span>)   <span class="co"># Replace all elements.  Argument is any enumerable</span>
s.clear           <span class="co"># =&gt; #&lt;Set: {}&gt;</span>
s.empty?          <span class="co"># =&gt; true</span></code></pre></div>
<h4 id="set-iterators">9.5.4.4 Set iterators</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">s = <span class="dt">Set</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>] <span class="co"># =&gt; #&lt;Set: {5, 1, 2, 3, 4}&gt;</span>
s.each {|x| print x }  <span class="co"># prints &quot;51234&quot;: arbitrary order before Ruby 1.9</span>
s.map! {|x| x*x }      <span class="co"># =&gt; #&lt;Set: {16, 1, 25, 9, 4}&gt;</span>
s.collect! {|x| x/<span class="dv">2</span> }  <span class="co"># =&gt; #&lt;Set: {0, 12, 2, 8, 4}&gt;</span></code></pre></div>
<h4 id="miscellaneous-set-methods">9.5.4.5 Miscellaneous set methods</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">s = (<span class="dv">1</span>..<span class="dv">3</span>).to_set
s.to_a          <span class="co"># =&gt; [1, 2, 3]</span>
s.to_s          <span class="co"># =&gt; &quot;#&lt;Set:0xb7e8f938&gt;&quot;: not useful</span>
s.inspect       <span class="co"># =&gt; &quot;#&lt;Set: {1, 2, 3}&gt;&quot;: useful       </span>
s == <span class="dt">Set</span>[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>] <span class="co"># =&gt; true: uses eql? to compare set elements</span>
<span class="co">###########################</span>
<span class="co"># Classify set elements as even or odd</span>
s = (<span class="dv">0</span>..<span class="dv">3</span>).to_set     <span class="co"># =&gt; #&lt;Set: {0, 1, 2, 3}&gt;</span>
s.classify {|x| x%<span class="dv">2</span>}  <span class="co"># =&gt; {0=&gt;#&lt;Set: {0, 2}&gt;, 1=&gt;#&lt;Set: {1, 3}&gt;}</span>
<span class="co">###########################</span>
s.divide {|x| x%<span class="dv">2</span>}  <span class="co"># =&gt; #&lt;Set: {#&lt;Set: {0, 2}&gt;, #&lt;Set: {1, 3}&gt;}&gt;</span>
<span class="co">###########################</span>
s =<span class="ot"> %w[</span><span class="st">ant ape cow hen hog</span><span class="ot">]</span>.to_set <span class="co"># A set of words</span>
s.divide {|x,y| x[<span class="dv">0</span>] == y[<span class="dv">0</span>]}      <span class="co"># Divide into subsets by first letter</span>
<span class="co"># =&gt; #&lt;Set:{#&lt;Set:{&quot;hog&quot;, &quot;hen&quot;}&gt;, #&lt;Set:{&quot;cow&quot;}&gt;, #&lt;Set:{&quot;ape&quot;, &quot;ant&quot;}&gt;}&gt;</span>
<span class="co">###########################</span>
s =<span class="ot"> %w[</span><span class="st">ant ape cow hen hog</span><span class="ot">]</span>.to_set <span class="co"># A set of words</span>
t = s.divide {|x,y| x[<span class="dv">0</span>] == y[<span class="dv">0</span>]}  <span class="co"># Divide it into subsets</span>
t.flatten!                         <span class="co"># Flatten the subsets</span>
t == s                             <span class="co"># =&gt; true</span></code></pre></div>
<h4 id="file-and-directory-names">9.6.1 File and Directory Names</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">full = <span class="st">&#39;/home/matz/bin/ruby.exe&#39;</span>
file=<span class="dt">File</span>.basename(full)     <span class="co"># =&gt; &#39;ruby.exe&#39;: just the local filename</span>
<span class="dt">File</span>.basename(full, <span class="st">&#39;.exe&#39;</span>)  <span class="co"># =&gt; &#39;ruby&#39;: with extension stripped</span>
dir=<span class="dt">File</span>.dirname(full)       <span class="co"># =&gt; &#39;/home/matz/bin&#39;: no / at end</span>
<span class="dt">File</span>.dirname(file)           <span class="co"># =&gt; &#39;.&#39;: current directory</span>
<span class="dt">File</span>.split(full)             <span class="co"># =&gt; [&#39;/home/matz/bin&#39;, &#39;ruby.exe&#39;]</span>
<span class="dt">File</span>.extname(full)           <span class="co"># =&gt; &#39;.exe&#39;</span>
<span class="dt">File</span>.extname(file)           <span class="co"># =&gt; &#39;.exe&#39;</span>
<span class="dt">File</span>.extname(dir)            <span class="co"># =&gt; &#39;&#39;</span>
<span class="dt">File</span>.join(<span class="st">&#39;home&#39;</span>,<span class="st">&#39;matz&#39;</span>)     <span class="co"># =&gt; &#39;home/matz&#39;: relative</span>
<span class="dt">File</span>.join(<span class="st">&#39;&#39;</span>,<span class="st">&#39;home&#39;</span>,<span class="st">&#39;matz&#39;</span>)  <span class="co"># =&gt; &#39;/home/matz&#39;: absolute</span>
<span class="co">###########################</span>
<span class="dt">Dir</span>.chdir(<span class="st">&quot;/usr/bin&quot;</span>)      <span class="co"># Current working directory is &quot;/usr/bin&quot;</span>
<span class="dt">File</span>.expand_path(<span class="st">&quot;ruby&quot;</span>)       <span class="co"># =&gt; &quot;/usr/bin/ruby&quot;</span>
<span class="dt">File</span>.expand_path(<span class="st">&quot;~/ruby&quot;</span>)     <span class="co"># =&gt; &quot;/home/david/ruby&quot;</span>
<span class="dt">File</span>.expand_path(<span class="st">&quot;~matz/ruby&quot;</span>) <span class="co"># =&gt; &quot;/home/matz/ruby&quot;</span>
<span class="dt">File</span>.expand_path(<span class="st">&quot;ruby&quot;</span>, <span class="st">&quot;/usr/local/bin&quot;</span>) <span class="co"># =&gt; &quot;/usr/local/bin/ruby&quot;</span>
<span class="dt">File</span>.expand_path(<span class="st">&quot;ruby&quot;</span>, <span class="st">&quot;../local/bin&quot;</span>)   <span class="co"># =&gt; &quot;/usr/local/bin/ruby&quot;</span>
<span class="dt">File</span>.expand_path(<span class="st">&quot;ruby&quot;</span>, <span class="st">&quot;~/bin&quot;</span>)          <span class="co"># =&gt; &quot;/home/david/bin/ruby&quot;</span>
<span class="co">###########################</span>
<span class="dt">File</span>.identical?(<span class="st">&quot;ruby&quot;</span>, <span class="st">&quot;ruby&quot;</span>)          <span class="co"># =&gt; true if the file exists</span>
<span class="dt">File</span>.identical?(<span class="st">&quot;ruby&quot;</span>, <span class="st">&quot;/usr/bin/ruby&quot;</span>) <span class="co"># =&gt; true if CWD is /usr/bin</span>
<span class="dt">File</span>.identical?(<span class="st">&quot;ruby&quot;</span>, <span class="st">&quot;../bin/ruby&quot;</span>)   <span class="co"># =&gt; true if CWD is /usr/bin</span>
<span class="dt">File</span>.identical?(<span class="st">&quot;ruby&quot;</span>, <span class="st">&quot;ruby1.9&quot;</span>)       <span class="co"># =&gt; true if there is a link</span>
<span class="co">###########################</span>
<span class="dt">File</span>.fnmatch(<span class="st">&quot;*.rb&quot;</span>, <span class="st">&quot;hello.rb&quot;</span>)     <span class="co"># =&gt; true</span>
<span class="dt">File</span>.fnmatch(<span class="st">&quot;*.[ch]&quot;</span>, <span class="st">&quot;ruby.c&quot;</span>)     <span class="co"># =&gt; true</span>
<span class="dt">File</span>.fnmatch(<span class="st">&quot;*.[ch]&quot;</span>, <span class="st">&quot;ruby.h&quot;</span>)     <span class="co"># =&gt; true</span>
<span class="dt">File</span>.fnmatch(<span class="st">&quot;?.txt&quot;</span>, <span class="st">&quot;ab.txt&quot;</span>)      <span class="co"># =&gt; false</span>
flags = <span class="dt">File</span>::<span class="dt">FNM_PATHNAME</span> | <span class="dt">File</span>::<span class="dt">FNM_DOTMATCH</span>
<span class="dt">File</span>.fnmatch(<span class="st">&quot;lib/*.rb&quot;</span>, <span class="st">&quot;lib/a.rb&quot;</span>, flags)      <span class="co"># =&gt; true</span>
<span class="dt">File</span>.fnmatch(<span class="st">&quot;lib/*.rb&quot;</span>, <span class="st">&quot;lib/a/b.rb&quot;</span>, flags)    <span class="co"># =&gt; false</span>
<span class="dt">File</span>.fnmatch(<span class="st">&quot;lib/**/*.rb&quot;</span>, <span class="st">&quot;lib/a.rb&quot;</span>, flags)   <span class="co"># =&gt; true</span>
<span class="dt">File</span>.fnmatch(<span class="st">&quot;lib/**/*.rb&quot;</span>, <span class="st">&quot;lib/a/b.rb&quot;</span>, flags) <span class="co"># =&gt; true</span></code></pre></div>
<h4 id="listing-directories">9.6.2 Listing Directories</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># Get the names of all files in the config/ directory </span>
filenames = <span class="dt">Dir</span>.entries(<span class="st">&quot;config&quot;</span>)        <span class="co"># Get names as an array</span>
<span class="dt">Dir</span>.foreach(<span class="st">&quot;config&quot;</span>) {|filename| ... }  <span class="co"># Iterate names</span>
<span class="co">###########################</span>
<span class="dt">Dir</span>[<span class="st">&#39;*.data&#39;</span>]       <span class="co"># Files with the &quot;data&quot; extension</span>
<span class="dt">Dir</span>[<span class="st">&#39;ruby.*&#39;</span>]       <span class="co"># Any filename beginning with &quot;ruby.&quot;</span>
<span class="dt">Dir</span>[<span class="st">&#39;?&#39;</span>]            <span class="co"># Any single-character filename</span>
<span class="dt">Dir</span>[<span class="st">&#39;*.[ch]&#39;</span>]       <span class="co"># Any file that ends with .c or .h</span>
<span class="dt">Dir</span>[<span class="st">&#39;*.{java,rb}&#39;</span>]  <span class="co"># Any file that ends with .java or .rb</span>
<span class="dt">Dir</span>[<span class="st">&#39;*/*.rb&#39;</span>]       <span class="co"># Any Ruby program in any direct sub-directory</span>
<span class="dt">Dir</span>[<span class="st">&#39;**/*.rb&#39;</span>]      <span class="co"># Any Ruby program in any descendant directory</span>
<span class="co">###########################</span>
<span class="dt">Dir</span>.glob(<span class="st">&#39;*.rb&#39;</span>) {|f| ... }      <span class="co"># Iterate all Ruby files</span>
<span class="dt">Dir</span>.glob(<span class="st">&#39;*&#39;</span>)                    <span class="co"># Does not include names beginning with &#39;.&#39;</span>
<span class="dt">Dir</span>.glob(<span class="st">&#39;*&#39;</span>,<span class="dt">File</span>::<span class="dt">FNM_DOTMATCH</span>) <span class="co"># Include . files, just like Dir.entries</span>
<span class="co">###########################</span>
puts <span class="dt">Dir</span>.getwd          <span class="co"># Print current working directory</span>
<span class="dt">Dir</span>.chdir(<span class="st">&quot;..&quot;</span>)         <span class="co"># Change CWD to the parent directory</span>
<span class="dt">Dir</span>.chdir(<span class="st">&quot;../sibling&quot;</span>) <span class="co"># Change again to a sibling directory</span>
<span class="dt">Dir</span>.chdir(<span class="st">&quot;/home&quot;</span>)      <span class="co"># Change to an absolute directory</span>
<span class="dt">Dir</span>.chdir               <span class="co"># Change to user&#39;s home directory</span>
home = <span class="dt">Dir</span>.pwd          <span class="co"># pwd is an alias for getwd</span></code></pre></div>
<h4 id="testing-files">9.6.3 Testing Files</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">f = <span class="st">&quot;/usr/bin/ruby&quot;</span>      <span class="co"># A filename for the examples below</span>

<span class="co"># File existence and types.</span>
<span class="dt">File</span>.exist?(f)           <span class="co"># Does the named file exist? Also: File.exists?</span>
<span class="dt">File</span>.file?(f)            <span class="co"># Is it an existing file?</span>
<span class="dt">File</span>.directory?(f)       <span class="co"># Or is it an existing directory?</span>
<span class="dt">File</span>.symlink?(f)         <span class="co"># Either way, is it a symbolic link?</span>

<span class="co"># File size methods. Use File.truncate to set file size.</span>
<span class="dt">File</span>.size(f)             <span class="co"># File size in bytes.</span>
<span class="dt">File</span>.size?(f)            <span class="co"># Size in bytes or nil if empty file.</span>
<span class="dt">File</span>.zero?(f)            <span class="co"># True if file is empty.</span>

<span class="co"># File permissions. Use File.chmod to set permissions (system dependent).</span>
<span class="dt">File</span>.readable?(f)        <span class="co"># Can we read the file?</span>
<span class="dt">File</span>.writable?(f)        <span class="co"># Can we write the file? No &quot;e&quot; in &quot;writable&quot;</span>
<span class="dt">File</span>.executable?(f)      <span class="co"># Can we execute the file?</span>
<span class="dt">File</span>.world_readable?(f)  <span class="co"># Can everybody read it? Ruby 1.9.</span>
<span class="dt">File</span>.world_writable?(f)  <span class="co"># Can everybody write it? Ruby 1.9.</span>

<span class="co"># File times/dates. Use File.utime to set the times.</span>
<span class="dt">File</span>.mtime(f)            <span class="co"># =&gt; Last modification time as a Time object</span>
<span class="dt">File</span>.atime(f)            <span class="co"># =&gt; Last access time as a Time object</span>
<span class="co">###########################</span>
<span class="dt">File</span>.ftype(<span class="st">&quot;/usr/bin/ruby&quot;</span>)    <span class="co"># =&gt; &quot;link&quot;</span>
<span class="dt">File</span>.ftype(<span class="st">&quot;/usr/bin/ruby1.9&quot;</span>) <span class="co"># =&gt; &quot;file&quot;</span>
<span class="dt">File</span>.ftype(<span class="st">&quot;/usr/lib/ruby&quot;</span>)    <span class="co"># =&gt; &quot;directory&quot;</span>
<span class="dt">File</span>.ftype(<span class="st">&quot;/usr/bin/ruby3.0&quot;</span>) <span class="co"># SystemCallError: No such file or directory</span>
<span class="co">###########################</span>
s = <span class="dt">File</span>.stat(<span class="st">&quot;/usr/bin/ruby&quot;</span>)
s.file?             <span class="co"># =&gt; true</span>
s.directory?        <span class="co"># =&gt; false</span>
s.ftype             <span class="co"># =&gt; &quot;file&quot;</span>
s.readable?         <span class="co"># =&gt; true</span>
s.writable?         <span class="co"># =&gt; false</span>
s.executable?       <span class="co"># =&gt; true</span>
s.size              <span class="co"># =&gt; 5492</span>
s.atime             <span class="co"># =&gt; Mon Jul 23 13:20:37 -0700 2007</span>
<span class="co">###########################</span>
<span class="co"># Testing single files</span>
test ?e, <span class="st">&quot;/usr/bin/ruby&quot;</span>   <span class="co"># File.exist?(&quot;/usr/bin/ruby&quot;)</span>
test ?f, <span class="st">&quot;/usr/bin/ruby&quot;</span>   <span class="co"># File.file?(&quot;/usr/bin/ruby&quot;)</span>
test ?d, <span class="st">&quot;/usr/bin/ruby&quot;</span>   <span class="co"># File.directory?(&quot;/usr/bin/ruby&quot;)</span>
test ?r, <span class="st">&quot;/usr/bin/ruby&quot;</span>   <span class="co"># File.readable?(&quot;/usr/bin/ruby&quot;)</span>
test ?w, <span class="st">&quot;/usr/bin/ruby&quot;</span>   <span class="co"># File.writeable?(&quot;/usr/bin/ruby&quot;)</span>
test ?M, <span class="st">&quot;/usr/bin/ruby&quot;</span>   <span class="co"># File.mtime(&quot;/usr/bin/ruby&quot;)</span>
test ?s, <span class="st">&quot;/usr/bin/ruby&quot;</span>   <span class="co"># File.size?(&quot;/usr/bin/ruby&quot;)</span>

<span class="co"># Comparing two files f and g</span>
test ?-, f, g              <span class="co"># File.identical(f,g)</span>
test ?&lt;, f, g              <span class="co"># File(f).mtime &lt; File(g).mtime</span>
test ?&gt;, f, g              <span class="co"># File(f).mtime &gt; File(g).mtime</span>
test ?=, f, g              <span class="co"># File(f).mtime == File(g).mtime</span></code></pre></div>
<h4 id="creating-deleting-and-renaming-files-and-directories">9.6.4 Creating, Deleting, and Renaming Files and Directories</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># Create (or overwrite) a file named &quot;test&quot;</span>
<span class="dt">File</span>.open(<span class="st">&quot;test&quot;</span>, <span class="st">&quot;w&quot;</span>) {}
<span class="co"># Create (but do not clobber) a file named &quot;test&quot;</span>
<span class="dt">File</span>.open(<span class="st">&quot;test&quot;</span>, <span class="st">&quot;a&quot;</span>) {}
<span class="co">###########################</span>
<span class="dt">File</span>.rename(<span class="st">&quot;test&quot;</span>, <span class="st">&quot;test.old&quot;</span>)     <span class="co"># Current name, then new name</span>
<span class="co">###########################</span>
<span class="dt">File</span>.symlink(<span class="st">&quot;test.old&quot;</span>, <span class="st">&quot;oldtest&quot;</span>) <span class="co"># Link target, link name</span>
<span class="co">###########################</span>
<span class="dt">File</span>.link(<span class="st">&quot;test.old&quot;</span>, <span class="st">&quot;test2&quot;</span>)   <span class="co"># Link target, link name</span>
<span class="co">###########################</span>
<span class="dt">File</span>.delete(<span class="st">&quot;test2&quot;</span>)   <span class="co"># May also be called with multiple args</span>
<span class="dt">File</span>.unlink(<span class="st">&quot;oldtest&quot;</span>) <span class="co"># to delete multiple named files</span>
<span class="co">###########################</span>
f = <span class="st">&quot;log.messages&quot;</span>          <span class="co"># Filename</span>
atime = mtime = <span class="dt">Time</span>.now    <span class="co"># New access and modify times</span>
<span class="dt">File</span>.truncate(f, <span class="dv">0</span>)         <span class="co"># Erase all existing content</span>
<span class="dt">File</span>.utime(atime, mtime, f) <span class="co"># Change times</span>
<span class="dt">File</span>.chmod(<span class="bn">0600</span>, f)         <span class="co"># Unix permissions -rw-------; note octal arg</span>
<span class="co">###########################</span>
<span class="dt">Dir</span>.mkdir(<span class="st">&quot;temp&quot;</span>)                 <span class="co"># Create a directory</span>
<span class="dt">File</span>.open(<span class="st">&quot;temp/f&quot;</span>, <span class="st">&quot;w&quot;</span>) {}       <span class="co"># Create a file in it</span>
<span class="dt">File</span>.open(<span class="st">&quot;temp/g&quot;</span>, <span class="st">&quot;w&quot;</span>) {}       <span class="co"># Create another one</span>
<span class="dt">File</span>.delete(*<span class="dt">Dir</span>[<span class="st">&quot;temp/*&quot;</span>])       <span class="co"># Delete all files in the directory</span>
<span class="dt">Dir</span>.rmdir(<span class="st">&quot;temp&quot;</span>)                 <span class="co"># Delete the directory</span></code></pre></div>
<h4 id="opening-files">9.7.1.1 Opening files</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">f = <span class="dt">File</span>.open(<span class="st">&quot;data.txt&quot;</span>, <span class="st">&quot;r&quot;</span>)   <span class="co"># Open file data.txt for reading</span>
out = <span class="dt">File</span>.open(<span class="st">&quot;out.txt&quot;</span>, <span class="st">&quot;w&quot;</span>)  <span class="co"># Open file out.txt for writing</span>
<span class="co">###########################</span>
<span class="dt">File</span>.open(<span class="st">&quot;log.txt&quot;</span>, <span class="st">&quot;a&quot;</span>) <span class="kw">do</span> |log|      <span class="co"># Open for appending</span>
  log.puts(<span class="st">&quot;INFO: Logging a message&quot;</span>)   <span class="co"># Output to the file</span>
<span class="kw">end</span>                                     <span class="co"># Automatically closed</span></code></pre></div>
<h4 id="kernel.open">9.7.1.2 Kernel.open</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># How long has the server been up?</span>
uptime = open(<span class="st">&quot;|uptime&quot;</span>) {|f| f.gets }
<span class="co">###########################</span>
require <span class="st">&quot;open-uri&quot;</span>                         <span class="co"># Required library</span>
f = open(<span class="st">&quot;http://www.davidflanagan.com/&quot;</span>)  <span class="co"># Webpage as a file</span>
webpage = f.read                           <span class="co"># Read it as one big string</span>
f.close                                    <span class="co"># Don&#39;t forget to close!</span></code></pre></div>
<h4 id="stringio">9.7.1.3 StringIO</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">require <span class="st">&quot;stringio&quot;</span>
input = <span class="dt">StringIO</span>.open(<span class="st">&quot;now is the time&quot;</span>)  <span class="co"># Read from this string</span>
buffer = <span class="st">&quot;&quot;</span>
output = <span class="dt">StringIO</span>.open(buffer, <span class="st">&quot;w&quot;</span>)       <span class="co"># Write into buffer</span></code></pre></div>
<h4 id="streams-and-encodings">9.7.2 Streams and Encodings</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">f.set_encoding(<span class="st">&quot;iso-8859-1&quot;</span>, <span class="st">&quot;utf-8&quot;</span>) <span class="co"># Latin-1, transcoded to UTF-8</span>
f.set_encoding(<span class="st">&quot;iso-8859-1:utf-8&quot;</span>)    <span class="co"># Same as above</span>
f.set_encoding(<span class="dt">Encoding</span>::<span class="dt">UTF</span><span class="dv">-8</span>)       <span class="co"># UTF-8 text</span>
<span class="co">###########################</span>
<span class="kw">in</span> = <span class="dt">File</span>.open(<span class="st">&quot;data.txt&quot;</span>, <span class="st">&quot;r:utf-8&quot;</span>);           <span class="co"># Read UTF-8 text</span>
out = <span class="dt">File</span>.open(<span class="st">&quot;log&quot;</span>, <span class="st">&quot;a:utf-8&quot;</span>);               <span class="co"># Write UTF-8 text</span>
<span class="kw">in</span> = <span class="dt">File</span>.open(<span class="st">&quot;data.txt&quot;</span>, <span class="st">&quot;r:iso8859-1:utf-8&quot;</span>); <span class="co"># Latin-1 transcoded to UTF-8 ```</span>
<span class="dt">File</span>.open(<span class="st">&quot;data&quot;</span>, <span class="st">&quot;r:binary&quot;</span>)  <span class="co"># Open a file for reading binary data&lt;/programlisting&gt;</span>

      &lt;para&gt;<span class="dt">On</span> <span class="dt">Windows</span>, you should open binary files with mode &lt;literal role=<span class="st">&quot;keep-together&quot;</span>&gt;<span class="st">&quot;rb:binary&quot;</span>&lt;<span class="ot">/literal&gt; or call &lt;literal role=&quot;keep-together&quot;&gt;binmode&lt;/</span>literal&gt; &lt;indexterm&gt;
          &lt;primary&gt;binmode method (<span class="dt">IO</span>)&lt;<span class="ot">/primary&gt;</span>
<span class="ot">        &lt;/in</span>dexterm&gt;on the stream. <span class="dt">This</span> disables the automatic newline
      conversion performed by <span class="dt">Windows</span>, <span class="kw">and</span> is only necessary on that
      platform.&lt;<span class="ot">/para&gt;</span>

<span class="ot">      &lt;para&gt;Not every stream-reading method honors the encoding of a stream.</span>
<span class="ot">      Some lower-level reading methods take an argument that specifies the</span>
<span class="ot">      number of bytes to read. By their nature, these methods return unencoded</span>
<span class="ot">      strings of bytes rather than strings of text. The methods that do not</span>
<span class="ot">      specify a length to read do honor the encoding.&lt;/</span>para&gt;
    &lt;<span class="ot">/sect2&gt;</span>

<span class="ot">    &lt;sect2&gt;</span>
<span class="ot">      &lt;title&gt;Reading from a Stream&lt;/</span>title&gt;

      &lt;para&gt;<span class="dt">The</span> &lt;literal&gt;<span class="dt">IO</span>&lt;<span class="ot">/literal&gt; class&lt;indexterm class=&quot;startofrange&quot; id=&quot;ch09-streams&quot;&gt;</span>
<span class="ot">          &lt;primary&gt;streams&lt;/</span>primary&gt;

          &lt;secondary&gt;reading from&lt;<span class="ot">/secondary&gt;</span>
<span class="ot">        &lt;/in</span>dexterm&gt; defines a number of methods <span class="kw">for</span> reading from streams.
      <span class="dt">They</span> work only <span class="kw">if</span> the stream is readable, of course. <span class="dt">You</span> can read
      &lt;indexterm&gt;
          &lt;primary&gt;<span class="dt">STDIN</span> stream&lt;<span class="ot">/primary&gt;</span>
<span class="ot">        &lt;/in</span>dexterm&gt;&lt;indexterm&gt;
          &lt;primary&gt;<span class="dt">ARGF</span> stream&lt;<span class="ot">/primary&gt;</span>
<span class="ot">        &lt;/in</span>dexterm&gt;&lt;indexterm&gt;
          &lt;primary&gt;<span class="dt">DATA</span> stream&lt;<span class="ot">/primary&gt;</span>
<span class="ot">        &lt;/in</span>dexterm&gt;&lt;indexterm&gt;
          &lt;primary&gt;<span class="dt">STDOUT</span> stream&lt;<span class="ot">/primary&gt;</span>
<span class="ot">        &lt;/in</span>dexterm&gt;&lt;indexterm&gt;
          &lt;primary&gt;<span class="dt">STDERR</span> stream&lt;<span class="ot">/primary&gt;</span>
<span class="ot">        &lt;/in</span>dexterm&gt;from &lt;literal&gt;<span class="dt">STDIN</span>&lt;<span class="ot">/literal&gt;, &lt;literal&gt;ARGF&lt;/</span>literal&gt;,
      <span class="kw">and</span> &lt;literal&gt;<span class="dt">DATA</span>&lt;<span class="ot">/literal&gt;, but not from &lt;literal&gt;STDOUT&lt;/</span>literal&gt; <span class="kw">or</span>
      &lt;literal&gt;<span class="dt">STDERR</span>&lt;<span class="ot">/literal&gt;. Files and &lt;literal&gt;StringIO&lt;/</span>literal&gt; objects
      are opened <span class="kw">for</span> reading by default, <span class="kw">unless</span> you explicitly open them <span class="kw">for</span>
      writing only.&lt;<span class="ot">/para&gt;</span>

<span class="ot">      &lt;sect3 id=&quot;readinglines&quot;&gt;</span>
<span class="ot">        &lt;title&gt;Reading lines&lt;/</span>title&gt;

        &lt;para&gt;&lt;literal&gt;<span class="dt">IO</span>&lt;<span class="ot">/literal&gt; defines a number of ways to read lines</span>
<span class="ot">        from a stream:&lt;/</span>para&gt;</code></pre></div>
<h4 id="reading-lines">9.7.3.1 Reading lines</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">        &lt;programlisting&gt;lines = <span class="dt">ARGF</span>.readlines         <span class="co"># Read all input, return an array of lines</span>
line = <span class="dt">DATA</span>.readline           <span class="co"># Read one line from stream</span>
print l <span class="kw">while</span> l = <span class="dt">DATA</span>.gets    <span class="co"># Read until gets returns nil, at EOF</span>
<span class="dt">DATA</span>.each {|line| print line } <span class="co"># Iterate lines from stream until EOF</span>
<span class="dt">DATA</span>.each_line                 <span class="co"># An alias for each</span>
<span class="dt">DATA</span>.lines                     <span class="co"># An enumerator for each_line: Ruby 1.9</span>
<span class="co">###########################</span>
print <span class="kw">while</span> <span class="dt">DATA</span>.gets
<span class="co">###########################</span>
<span class="dt">DATA</span>.lineno = <span class="dv">0</span>     <span class="co"># Start from line 0, even though data is at end of file</span>
<span class="dt">DATA</span>.readline       <span class="co"># Read one line of data</span>
<span class="dt">DATA</span>.lineno         <span class="co"># =&gt; 1</span>
<span class="dt">$.</span>                  <span class="co"># =&gt; 1: magic global variable, implicitly set</span></code></pre></div>
<h4 id="reading-entire-files">9.7.3.2 Reading entire files</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">data = <span class="dt">IO</span>.read(<span class="st">&quot;data&quot;</span>)         <span class="co"># Read and return the entire file</span>
data = <span class="dt">IO</span>.read(<span class="st">&quot;data&quot;</span>, <span class="dv">4</span>, <span class="dv">2</span>)   <span class="co"># Read 4 bytes starting at byte 2</span>
data = <span class="dt">IO</span>.read(<span class="st">&quot;data&quot;</span>, <span class="dv">nil</span>, <span class="dv">6</span>) <span class="co"># Read from byte 6 to end-of-file</span>

<span class="co"># Read lines into an array</span>
words = <span class="dt">IO</span>.readlines(<span class="st">&quot;/usr/share/dict/words&quot;</span>)

<span class="co"># Read lines one at a time and initialize a hash</span>
words = {}
<span class="dt">IO</span>.foreach(<span class="st">&quot;/usr/share/dict/words&quot;</span>) {|w| words[w] = <span class="dv">true</span>}
<span class="co">###########################</span>
<span class="co"># An alternative to text = File.read(&quot;data.txt&quot;)</span>
f = <span class="dt">File</span>.open(<span class="st">&quot;data.txt&quot;</span>)  <span class="co"># Open a file</span>
text = f.read              <span class="co"># Read its contents as text</span>
f.close                    <span class="co"># Close the file</span></code></pre></div>
<h4 id="reading-bytes-and-characters">9.7.3.3 Reading bytes and characters</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">f = <span class="dt">File</span>.open(<span class="st">&quot;data&quot;</span>, <span class="st">&quot;r:binary&quot;</span>) <span class="co"># Open data file for binary reads </span>
c = f.getc                        <span class="co"># Read the first byte as an integer</span>
f.ungetc(c)                       <span class="co"># Push that byte back</span>
c = f.readchar                    <span class="co"># Read it back again</span>
<span class="co">###########################</span>
f.each_byte {|b| ... }      <span class="co"># Iterate through remaining bytes</span>
f.bytes                     <span class="co"># An enumerator for each_byte: Ruby 1.9</span>
<span class="co">###########################</span>
f = <span class="dt">File</span>.open(<span class="st">&quot;data.bin&quot;</span>, <span class="st">&quot;rb:binary&quot;</span>)  <span class="co"># No newline conversion, no encoding</span>
magic = f.readbytes(<span class="dv">4</span>)       <span class="co"># First four bytes identify filetype</span>
exit <span class="kw">unless</span> magic == <span class="st">&quot;INTS&quot;</span>  <span class="co"># Magic number spells &quot;INTS&quot; (ASCII)</span>
bytes = f.read               <span class="co"># Read the rest of the file</span>
                             <span class="co"># Encoding is binary, so this is a byte string</span>
data = bytes.unpack(<span class="st">&quot;i*&quot;</span>)    <span class="co"># Convert bytes to an array of integers</span></code></pre></div>
<h4 id="writing-to-a-stream">9.7.4 Writing to a Stream</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">o = <span class="dt">STDOUT</span>
<span class="co"># Single-character output</span>
o.putc(<span class="dv">65</span>)         <span class="co"># Write single byte 65 (capital A)</span>
o.putc(<span class="st">&quot;B&quot;</span>)        <span class="co"># Write single byte 66 (capital B)</span>
o.putc(<span class="st">&quot;CD&quot;</span>)       <span class="co"># Write just the first byte of the string</span>
<span class="co">###########################</span>
o = <span class="dt">STDOUT</span>
<span class="co"># String output</span>
o &lt;&lt; x             <span class="co"># Output x.to_s </span>
o &lt;&lt; x &lt;&lt; y        <span class="co"># May be chained: output x.to_s + y.to_s</span>
o.print            <span class="co"># Output $_ + $\</span>
o.print s          <span class="co"># Output s.to_s + $\</span>
o.print s,t        <span class="co"># Output s.to_s + t.to_s + $\</span>
o.printf fmt,*args <span class="co"># Outputs fmt%[args]</span>
o.puts             <span class="co"># Output newline</span>
o.puts x           <span class="co"># Output x.to_s.chomp plus newline</span>
o.puts x,y         <span class="co"># Output x.to_s.chomp, newline, y.to_s.chomp, newline</span>
o.puts [x,y]       <span class="co"># Same as above</span>
o.write s          <span class="co"># Output s.to_s, returns s.to_s.length</span>
o.syswrite s       <span class="co"># Low-level version of write</span></code></pre></div>
<h4 id="random-access-methods">9.7.5 Random Access Methods</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">f = <span class="dt">File</span>.open(<span class="st">&quot;test.txt&quot;</span>)
f.pos        <span class="co"># =&gt; 0: return the current position in bytes</span>
f.pos = <span class="dv">10</span>   <span class="co"># skip to position 10</span>
f.tell       <span class="co"># =&gt; 10: a synonym for pos</span>
f.rewind     <span class="co"># go back to position 0, reset lineno to 0, also</span>
f.seek(<span class="dv">10</span>, <span class="dt">IO</span>::<span class="dt">SEEK_SET</span>)  <span class="co"># Skip to absolute position 10</span>
f.seek(<span class="dv">10</span>, <span class="dt">IO</span>::<span class="dt">SEEK_CUR</span>)  <span class="co"># Skip 10 bytes from current position</span>
f.seek(-<span class="dv">10</span>, <span class="dt">IO</span>::<span class="dt">SEEK_END</span>) <span class="co"># Skip to 10 bytes from end</span>
f.seek(<span class="dv">0</span>, <span class="dt">IO</span>::<span class="dt">SEEK_END</span>)   <span class="co"># Skip to very end of file</span>
f.eof?                    <span class="co"># =&gt; true: we&#39;re at the end</span>
<span class="co">###########################</span>
pos = f.sysseek(<span class="dv">0</span>, <span class="dt">IO</span>::<span class="dt">SEEK_CUR</span>)  <span class="co"># Get current position</span>
f.sysseek(<span class="dv">0</span>, <span class="dt">IO</span>::<span class="dt">SEEK_SET</span>)        <span class="co"># Rewind stream</span>
f.sysseek(pos, <span class="dt">IO</span>::<span class="dt">SEEK_SET</span>)      <span class="co"># Return to original position</span></code></pre></div>
<h4 id="closing-flushing-and-testing-streams">9.7.6 Closing, Flushing, and Testing Streams</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="dt">File</span>.open(<span class="st">&quot;test.txt&quot;</span>) <span class="kw">do</span> |f|
  <span class="co"># Use stream f here</span>
  <span class="co"># Value of this block becomes return value of the open method</span>
<span class="kw">end</span> <span class="co"># f is automatically closed for us here</span>
<span class="co">###########################</span>
<span class="kw">begin</span>
  f = <span class="dt">File</span>.open(<span class="st">&quot;test.txt&quot;</span>)
  <span class="co"># use stream f here</span>
<span class="kw">ensure</span>
  f.close <span class="kw">if</span> f
<span class="kw">end</span>
<span class="co">###########################</span>
out.print <span class="st">&#39;wait&gt;&#39;</span> <span class="co"># Display a prompt</span>
out.flush         <span class="co"># Manually flush output buffer to OS</span>
sleep(<span class="dv">1</span>)          <span class="co"># Prompt appears before we go to sleep</span>

out.sync = <span class="dv">true</span>   <span class="co"># Automatically flush buffer after every write</span>
out.sync = <span class="dv">false</span>  <span class="co"># Don&#39;t automatically flush</span>
out.sync          <span class="co"># Return current sync mode</span>
out.fsync         <span class="co"># Flush output buffer and ask OS to flush its buffers</span>
                  <span class="co"># Returns nil if unsupported on current platform</span>
<span class="co">###########################</span>
f.eof?       <span class="co"># true if stream is at EOF</span>
f.closed?    <span class="co"># true if stream has been closed</span>
f.tty?       <span class="co"># true if stream is interactive</span></code></pre></div>
<h4 id="networking">9.8 Networking</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">require <span class="st">&#39;socket&#39;</span></code></pre></div>
<h4 id="a-very-simple-client">9.8.1 A Very Simple Client</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">require <span class="st">&#39;socket&#39;</span>                <span class="co"># Sockets are in standard library</span>

host, port = <span class="dt">ARGV</span>               <span class="co"># Host and port from command line</span>

s = <span class="dt">TCPSocket</span>.open(host, port)  <span class="co"># Open a socket to host and port</span>
<span class="kw">while</span> line = s.gets             <span class="co"># Read lines from the socket</span>
  puts line.chop                <span class="co"># And print with platform line terminator</span>
<span class="kw">end</span>
s.close                         <span class="co"># Close the socket when done</span>
<span class="co">###########################</span>
require <span class="st">&#39;socket&#39;</span>                  
host, port = <span class="dt">ARGV</span>                 
<span class="dt">TCPSocket</span>.open(host, port) <span class="kw">do</span> |s| <span class="co"># Use block form of open</span>
  <span class="kw">while</span> line = s.gets             
    puts line.chop                
  <span class="kw">end</span>
<span class="kw">end</span>                               <span class="co"># Socket automatically closed</span></code></pre></div>
<h4 id="a-very-simple-server">9.8.2 A Very Simple Server</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">require <span class="st">&#39;socket&#39;</span>               <span class="co"># Get sockets from stdlib</span>

server = <span class="dt">TCPServer</span>.open(<span class="dv">2000</span>)  <span class="co"># Socket to listen on port 2000</span>
loop {                         <span class="co"># Infinite loop: servers run forever</span>
  client = server.accept       <span class="co"># Wait for a client to connect</span>
  client.puts(<span class="dt">Time</span>.now.ctime)  <span class="co"># Send the time to the client</span>
  client.close                 <span class="co"># Disconnect from the client</span>
}
<span class="co">###########################</span>
ruby client.rb localhost <span class="dv">2000</span></code></pre></div>
<h4 id="datagrams">9.8.3 Datagrams</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">require <span class="st">&#39;socket&#39;</span>                     <span class="co"># Standard library</span>

host, port, request = <span class="dt">ARGV</span>           <span class="co"># Get args from command line</span>

ds = <span class="dt">UDPSocket</span>.new                   <span class="co"># Create datagram socket</span>
ds.connect(host, port)               <span class="co"># Connect to the port on the host</span>
ds.send(request, <span class="dv">0</span>)                  <span class="co"># Send the request text</span>
response,address = ds.recvfrom(<span class="dv">1024</span>) <span class="co"># Wait for a response (1kb max)</span>
puts response                        <span class="co"># Print the response</span>
<span class="co">###########################</span>
require <span class="st">&#39;socket&#39;</span>                     <span class="co"># Standard library</span>

port = <span class="dt">ARGV</span>[<span class="dv">0</span>]                       <span class="co"># The port to listen on</span>

ds = <span class="dt">UDPSocket</span>.new                   <span class="co"># Create new socket</span>
ds.bind(<span class="dv">nil</span>, port)                   <span class="co"># Make it listen on the port</span>
loop <span class="kw">do</span>                              <span class="co"># Loop forever</span>
  request,address=ds.recvfrom(<span class="dv">1024</span>)  <span class="co"># Wait to receive something</span>
  response = request.upcase          <span class="co"># Convert request text to uppercase</span>
  clientaddr = address[<span class="dv">3</span>]            <span class="co"># What ip address sent the request?</span>
  clientname = address[<span class="dv">2</span>]            <span class="co"># What is the host name?</span>
  clientport = address[<span class="dv">1</span>]            <span class="co"># What port was it sent from</span>
  ds.send(response, <span class="dv">0</span>,               <span class="co"># Send the response back...</span>
          clientaddr, clientport)    <span class="co"># ...where it came from</span>
  <span class="co"># Log the client connection</span>
  puts <span class="st">&quot;Connection from: </span><span class="ot">#{</span>clientname<span class="ot">}</span><span class="st"> </span><span class="ot">#{</span>clientaddr<span class="ot">}</span><span class="st"> </span><span class="ot">#{</span>clientport<span class="ot">}</span><span class="st">&quot;</span>
<span class="kw">end</span></code></pre></div>
<h4 id="a-more-complex-client">9.8.4 A More Complex Client</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">require <span class="st">&#39;socket&#39;</span>     <span class="co"># Sockets from standard library</span>

host, port = <span class="dt">ARGV</span>    <span class="co"># Network host and port on command line</span>

<span class="kw">begin</span>                <span class="co"># Begin for exception handling</span>
  <span class="co"># Give the user some feedback while connecting.</span>
  <span class="dt">STDOUT</span>.print <span class="st">&quot;Connecting...&quot;</span>      <span class="co"># Say what we&#39;re doing</span>
  <span class="dt">STDOUT</span>.flush                      <span class="co"># Make it visible right away</span>
  s = <span class="dt">TCPSocket</span>.open(host, port)    <span class="co"># Connect</span>
  <span class="dt">STDOUT</span>.puts <span class="st">&quot;done&quot;</span>                <span class="co"># And say we did it</span>

  <span class="co"># Now display information about the connection.</span>
  local, peer = s.addr, s.peeraddr
  <span class="dt">STDOUT</span>.print <span class="st">&quot;Connected to </span><span class="ot">#{</span>peer[<span class="dv">2</span>]<span class="ot">}</span><span class="st">:</span><span class="ot">#{</span>peer[<span class="dv">1</span>]<span class="ot">}</span><span class="st">&quot;</span>
  <span class="dt">STDOUT</span>.puts <span class="st">&quot; using local port </span><span class="ot">#{</span>local[<span class="dv">1</span>]<span class="ot">}</span><span class="st">&quot;</span>

  <span class="co"># Wait just a bit, to see if the server sends any initial message.</span>
  <span class="kw">begin</span>
    sleep(<span class="fl">0.5</span>)                      <span class="co"># Wait half a second</span>
    msg = s.read_nonblock(<span class="dv">4096</span>)     <span class="co"># Read whatever is ready</span>
    <span class="dt">STDOUT</span>.puts msg.chop            <span class="co"># And display it</span>
  <span class="kw">rescue</span> <span class="dt">SystemCallError</span>
    <span class="co"># If nothing was ready to read, just ignore the exception.</span>
  <span class="kw">end</span>

  <span class="co"># Now begin a loop of client/server interaction.</span>
  loop <span class="kw">do</span>
    <span class="dt">STDOUT</span>.print <span class="st">&#39;&gt; &#39;</span>   <span class="co"># Display prompt for local input</span>
    <span class="dt">STDOUT</span>.flush        <span class="co"># Make sure the prompt is visible</span>
    local = <span class="dt">STDIN</span>.gets  <span class="co"># Read line from the console</span>
    <span class="kw">break</span> <span class="kw">if</span> !local     <span class="co"># Quit if no input from console</span>

    s.puts(local)       <span class="co"># Send the line to the server</span>
    s.flush             <span class="co"># Force it out</span>

    <span class="co"># Read the server&#39;s response and print out.</span>
    <span class="co"># The server may send more than one line, so use readpartial</span>
    <span class="co"># to read whatever it sends (as long as it all arrives in one chunk).</span>
    response = s.readpartial(<span class="dv">4096</span>) <span class="co"># Read server&#39;s response</span>
    puts(response.chop)            <span class="co"># Display response to user</span>
  <span class="kw">end</span>
<span class="kw">rescue</span>           <span class="co"># If anything goes wrong</span>
  puts <span class="dt">$!</span>        <span class="co"># Display the exception to the user</span>
<span class="kw">ensure</span>           <span class="co"># And no matter what happens</span>
  s.close <span class="kw">if</span> s   <span class="co"># Don&#39;t forget to close the socket</span>
<span class="kw">end</span></code></pre></div>
<h4 id="a-multiplexing-server">9.8.5 A Multiplexing Server</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># This server reads a line of input from a client, reverses</span>
<span class="co"># the line and sends it back. If the client sends the string &quot;quit&quot;</span>
<span class="co"># it disconnects. It uses Kernel.select to handle multiple sessions.</span>

require <span class="st">&#39;socket&#39;</span>           

server = <span class="dt">TCPServer</span>.open(<span class="dv">2000</span>) <span class="co"># Listen on port 2000</span>
sockets = [server]            <span class="co"># An array of sockets we&#39;ll monitor</span>
log = <span class="dt">STDOUT</span>                  <span class="co"># Send log messages to standard out</span>
<span class="kw">while</span> <span class="dv">true</span>                    <span class="co"># Servers loop forever</span>
  ready = select(sockets)     <span class="co"># Wait for a socket to be ready</span>
  readable = ready[<span class="dv">0</span>]         <span class="co"># These sockets are readable</span>

  readable.each <span class="kw">do</span> |socket|         <span class="co"># Loop through readable sockets</span>
    <span class="kw">if</span> socket == server             <span class="co"># If the server socket is ready</span>
      client = server.accept        <span class="co"># Accept a new client</span>
      sockets &lt;&lt; client             <span class="co"># Add it to the set of sockets</span>
      <span class="co"># Tell the client what and where it has connected.</span>
      client.puts <span class="st">&quot;Reversal service v0.01 running on </span><span class="ot">#{</span><span class="dt">Socket</span>.gethostname<span class="ot">}</span><span class="st">&quot;</span>
      <span class="co"># And log the fact that the client connected</span>
      log.puts <span class="st">&quot;Accepted connection from </span><span class="ot">#{</span>client.peeraddr[<span class="dv">2</span>]<span class="ot">}</span><span class="st">&quot;</span>
    <span class="kw">else</span>                            <span class="co"># Otherwise, a client is ready</span>
      input = socket.gets           <span class="co"># Read input from the client</span>

      <span class="co"># If no input, the client has disconnected</span>
      <span class="kw">if</span> !input   
        log.puts <span class="st">&quot;Client on </span><span class="ot">#{</span>socket.peeraddr[<span class="dv">2</span>]<span class="ot">}</span><span class="st"> disconnected.&quot;</span>
        sockets.delete(socket)      <span class="co"># Stop monitoring this socket</span>
        socket.close                <span class="co"># Close it</span>
        <span class="kw">next</span>                        <span class="co"># And go on to the next</span>
      <span class="kw">end</span>

      input.chop!                   <span class="co"># Trim client&#39;s input</span>
      <span class="kw">if</span> (input == <span class="st">&quot;quit&quot;</span>)          <span class="co"># If the client asks to quit</span>
        socket.puts(<span class="st">&quot;Bye!&quot;</span>);        <span class="co"># Say goodbye</span>
        log.puts <span class="st">&quot;Closing connection to </span><span class="ot">#{</span>socket.peeraddr[<span class="dv">2</span>]<span class="ot">}</span><span class="st">&quot;</span>
        sockets.delete(socket)      <span class="co"># Stop monitoring the socket</span>
        socket.close                <span class="co"># Terminate the session</span>
      <span class="kw">else</span>                          <span class="co"># Otherwise, client is not quitting</span>
        socket.puts(input.reverse)  <span class="co"># So reverse input and send it back</span>
      <span class="kw">end</span>
    <span class="kw">end</span>
  <span class="kw">end</span>
<span class="kw">end</span></code></pre></div>
<h4 id="fetching-web-pages">9.8.6 Fetching Web Pages</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">require <span class="st">&#39;socket&#39;</span>           <span class="co"># We need sockets</span>
 
host = <span class="st">&#39;www.example.com&#39;</span>   <span class="co"># The web server</span>
port = <span class="dv">80</span>                  <span class="co"># Default HTTP port</span>
path = <span class="st">&quot;/index.html&quot;</span>       <span class="co"># The file we want </span>

<span class="co"># This is the HTTP request we send to fetch a file</span>
request = <span class="st">&quot;GET </span><span class="ot">#{</span>path<span class="ot">}</span><span class="st"> HTTP/1.0\r\n\r\n&quot;</span>

socket = <span class="dt">TCPSocket</span>.open(host,port)  <span class="co"># Connect to server</span>
socket.print(request)               <span class="co"># Send request</span>
response = socket.read              <span class="co"># Read complete response</span>
<span class="co"># Split response at first blank line into headers and body</span>
headers,body = response.split(<span class="st">&quot;\r\n\r\n&quot;</span>, <span class="dv">2</span>) 
print body                          <span class="co"># And display it</span>
<span class="co">###########################</span>
require <span class="st">&#39;net/http&#39;</span>         <span class="co"># The library we need</span>
host = <span class="st">&#39;www.example.com&#39;</span>   <span class="co"># The web server</span>
path = <span class="st">&#39;/index.html&#39;</span>       <span class="co"># The file we want </span>

http = <span class="dt">Net</span>::<span class="dt">HTTP</span>.new(host)      <span class="co"># Create a connection</span>
headers, body = http.get(path)  <span class="co"># Request the file</span>
<span class="kw">if</span> headers.code == <span class="st">&quot;200&quot;</span>        <span class="co"># Check the status code   </span>
                                <span class="co"># NOTE: code is not a number!</span>
  print body                    <span class="co"># Print body if we got it</span>
<span class="kw">else</span>                            <span class="co"># Otherwise</span>
  puts <span class="st">&quot;</span><span class="ot">#{</span>headers.code<span class="ot">}</span><span class="st"> </span><span class="ot">#{</span>headers.message<span class="ot">}</span><span class="st">&quot;</span> <span class="co"># Display error message</span>
<span class="kw">end</span>
<span class="co">###########################</span>
require <span class="st">&#39;open-uri&#39;</span>
open(<span class="st">&quot;http://www.example.com/index.html&quot;</span>) {|f|
  puts f.read
}</code></pre></div>
<h4 id="threads-and-concurrency">9.9 Threads and Concurrency</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># Thread #1 is running here</span>
<span class="dt">Thread</span>.new {
  <span class="co"># Thread #2 runs this code</span>
}
<span class="co"># Thread #1 runs this code</span></code></pre></div>
<h4 id="the-main-thread">9.9.1.1 The main thread</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># Wait for all threads (other than the current thread and</span>
<span class="co"># main thread) to stop running.</span>
<span class="co"># Assumes that no new threads are started while waiting.</span>
<span class="kw">def</span> join_all
  main = <span class="dt">Thread</span>.main        <span class="co"># The main thread</span>
  current = <span class="dt">Thread</span>.current  <span class="co"># The current thread</span>
  all = <span class="dt">Thread</span>.list         <span class="co"># All threads still running</span>
  <span class="co"># Now call join on each thread</span>
  all.each {|t| t.join <span class="kw">unless</span> t == current <span class="kw">or</span> t == main }
<span class="kw">end</span></code></pre></div>
<h4 id="threads-and-unhandled-exceptions">9.9.1.2 Threads and unhandled exceptions</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="dt">Thread</span>.abort_on_exception = <span class="dv">true</span>
<span class="co">###########################</span>
t = <span class="dt">Thread</span>.new { ... }
t.abort_on_exception = <span class="dv">true</span></code></pre></div>
<h4 id="threads-and-variables">9.9.2 Threads and Variables</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">x = <span class="dv">0</span>

t1 = <span class="dt">Thread</span>.new <span class="kw">do</span>
  <span class="co"># This thread can query and set the variable x</span>
<span class="kw">end</span>

t2 = <span class="dt">Thread</span>.new <span class="kw">do</span>
  <span class="co"># This thread and also query and set x</span>
  <span class="co"># And it can query and set t1 and t2 as well.   </span>
<span class="kw">end</span></code></pre></div>
<h4 id="thread-private-variables">9.9.2.1 Thread-private variables</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">n = <span class="dv">1</span>
<span class="kw">while</span> n &lt;= <span class="dv">3</span>
  <span class="dt">Thread</span>.new { puts n }
  n += <span class="dv">1</span>
<span class="kw">end</span> 
<span class="co">###########################</span>
n = <span class="dv">1</span>
<span class="kw">while</span> n &lt;= <span class="dv">3</span>
  <span class="co"># Get a private copy of the current value of n in x</span>
  <span class="dt">Thread</span>.new(n) {|x| puts x }
  n += <span class="dv">1</span>
<span class="kw">end</span> 
<span class="co">###########################</span>
<span class="dv">1</span>.upto(<span class="dv">3</span>) {|n| <span class="dt">Thread</span>.new { puts n }}</code></pre></div>
<h4 id="thread-local-variables">9.9.2.2 Thread-local variables</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="dt">Thread</span>.current[<span class="st">:progress</span>] = bytes_received
<span class="co">###########################</span>
total = <span class="dv">0</span>
download_threads.each {|t| total += t[<span class="st">:progress</span>] }
<span class="co">###########################</span>
total = <span class="dv">0</span>
download_threads.each {|t| total += t[<span class="st">:progress</span>] <span class="kw">if</span> t.key?(<span class="st">:progress</span>)}</code></pre></div>
<h4 id="listing-threads-and-thread-groups">9.9.5 Listing Threads and Thread Groups</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">group = <span class="dt">ThreadGroup</span>.new
<span class="dv">3</span>.times {|n| group.add(<span class="dt">Thread</span>.new { do_task(n) }}</code></pre></div>
<h4 id="reading-files-concurrently">9.9.6.1 Reading files concurrently</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># Read files concurrently. Use with the &quot;open-uri&quot; module to fetch URLs.</span>
<span class="co"># Pass an array of filenames. Returns a hash mapping filenames to content.</span>
<span class="kw">def</span> conread(filenames)
  h = {}                            <span class="co"># Empty hash of results</span>

  <span class="co"># Create one thread for each file</span>
  filenames.each <span class="kw">do</span> |filename|      <span class="co"># For each named file</span>
    h[filename] = <span class="dt">Thread</span>.new <span class="kw">do</span>     <span class="co"># Create a thread, map to filename</span>
      open(filename) {|f| f.read }  <span class="co"># Open and read the file</span>
    <span class="kw">end</span>                             <span class="co"># Thread value is file contents</span>
  <span class="kw">end</span>

  <span class="co"># Iterate through the hash, waiting for each thread to complete.</span>
  <span class="co"># Replace the thread in the hash with its value (the file contents)</span>
  h.each_pair <span class="kw">do</span> |filename, thread| 
    <span class="kw">begin</span>
      h[filename] = thread.value    <span class="co"># Map filename to file contents</span>
    <span class="kw">rescue</span>
      h[filename] = <span class="dt">$!</span>              <span class="co"># Or to the exception raised</span>
    <span class="kw">end</span>
  <span class="kw">end</span>
<span class="kw">end</span></code></pre></div>
<h4 id="a-multithreaded-server">9.9.6.2 A Multithreaded Server</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">require <span class="st">&#39;socket&#39;</span>

<span class="co"># This method expects a socket connected to a client.</span>
<span class="co"># It reads lines from the client, reverses them and sends them back.</span>
<span class="co"># Multiple threads may run this method at the same time.</span>
<span class="kw">def</span> handle_client(c)
  <span class="kw">while</span> <span class="dv">true</span>
    input = c.gets.chop     <span class="co"># Read a line of input from the client</span>
    <span class="kw">break</span> <span class="kw">if</span> !input         <span class="co"># Exit if no more input</span>
    <span class="kw">break</span> <span class="kw">if</span> input==<span class="st">&quot;quit&quot;</span>  <span class="co"># or if the client asks to.</span>
    c.puts(input.reverse)   <span class="co"># Otherwise, respond to client.</span>
    c.flush                 <span class="co"># Force our output out</span>
  <span class="kw">end</span>
  c.close                   <span class="co"># Close the client socket</span>
<span class="kw">end</span>


server = <span class="dt">TCPServer</span>.open(<span class="dv">2000</span>) <span class="co"># Listen on port 2000</span>

<span class="kw">while</span> <span class="dv">true</span>                    <span class="co"># Servers loop forever</span>
  client = server.accept      <span class="co"># Wait for a client to connect</span>
  <span class="dt">Thread</span>.start(client) <span class="kw">do</span> |c| <span class="co"># Start a new thread </span>
    handle_client(c)          <span class="co"># And handle the client on that thread</span>
  <span class="kw">end</span>
<span class="kw">end</span></code></pre></div>
<h4 id="concurrent-iterators">9.9.6.3 Concurrent iterators</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">module</span> <span class="dt">Enumerable</span>           <span class="co"># Open the Enumerable module</span>
  <span class="kw">def</span> conmap(&amp;block)        <span class="co"># Define a new method that expects a block</span>
    threads = []            <span class="co"># Start with an empty array of threads</span>
    <span class="dv">self</span>.each <span class="kw">do</span> |item|     <span class="co"># For each enumerable item</span>
      <span class="co"># Invoke the block in a new thread, and remember the thread</span>
      threads &lt;&lt; <span class="dt">Thread</span>.new { block.call(item) }
    <span class="kw">end</span>
    <span class="co"># Now map the array of threads to their values </span>
    threads.map {|t| t.value } <span class="co"># And return the array of values</span>
  <span class="kw">end</span>
<span class="kw">end</span>
<span class="co">###########################</span>
<span class="kw">module</span> <span class="dt">Enumerable</span>
  <span class="kw">def</span> concurrently
    map {|item| <span class="dt">Thread</span>.new { <span class="kw">yield</span> item }}.each {|t| t.join }
  <span class="kw">end</span>
<span class="kw">end</span>
<span class="co">###########################</span>
h.each_pair.concurrently {|*pair| process(pair)}</code></pre></div>
<h4 id="thread-exclusion-and-deadlock">9.9.7 Thread Exclusion and Deadlock</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">require <span class="st">&#39;thread&#39;</span>  <span class="co"># For Mutex class in Ruby 1.8</span>

<span class="co"># A BankAccount has a name, a checking amount, and a savings amount.</span>
<span class="kw">class</span> <span class="dt">BankAccount</span>
  <span class="kw">def</span> init(name, checking, savings)
    <span class="ot">@name</span>,<span class="ot">@checking</span>,<span class="ot">@savings</span> = name,checking,savings 
    <span class="ot">@lock</span> = <span class="dt">Mutex</span>.new         <span class="co"># For thread safety</span>
  <span class="kw">end</span>

  <span class="co"># Lock account and transfer money from savings to checking</span>
  <span class="kw">def</span> transfer_from_savings(x)
    <span class="ot">@lock</span>.synchronize {
      <span class="ot">@savings</span> -= x
      <span class="ot">@checking</span> += x
    }
  <span class="kw">end</span>

  <span class="co"># Lock account and report current balances</span>
  <span class="kw">def</span> report
    <span class="ot">@lock</span>.synchronize {
      <span class="st">&quot;</span><span class="ot">#@name</span><span class="st">\nChecking: </span><span class="ot">#@checking</span><span class="st">\nSavings: </span><span class="ot">#@savings</span><span class="st">&quot;</span>
    }
  <span class="kw">end</span>
<span class="kw">end</span></code></pre></div>
<h4 id="deadlock">9.9.7.1 Deadlock</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># Classic deadlock: two threads and two locks</span>
require <span class="st">&#39;thread&#39;</span>

m,n = <span class="dt">Mutex</span>.new, <span class="dt">Mutex</span>.new

t = <span class="dt">Thread</span>.new {
  m.lock
  puts <span class="st">&quot;Thread t locked Mutex m&quot;</span>
  sleep <span class="dv">1</span>
  puts <span class="st">&quot;Thread t waiting to lock Mutex n&quot;</span>
  n.lock
}

s = <span class="dt">Thread</span>.new {
  n.lock
  puts <span class="st">&quot;Thread s locked Mutex n&quot;</span>
  sleep <span class="dv">1</span>
  puts <span class="st">&quot;Thread s waiting to lock Mutex m&quot;</span>
  m.lock
}

t.join
s.join</code></pre></div>
<h4 id="queue-and-sizedqueue">9.9.8 Queue and SizedQueue</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">a = [-<span class="dv">2</span>,-<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>]
mapper = lambda {|x| x*x }             <span class="co"># Compute squares</span>
injector = lambda {|total,x| total+x } <span class="co"># Compute sum</span>
a.conject(<span class="dv">0</span>, mapper, injector)         <span class="co"># =&gt; 10</span>
<span class="co">###########################</span>
<span class="kw">module</span> <span class="dt">Enumerable</span>
  <span class="co"># Concurrent inject: expects an initial value and two Procs</span>
  <span class="kw">def</span> conject(initial, mapper, injector)
    <span class="co"># Use a Queue to pass values from mapping threads to injector thread</span>
    q = <span class="dt">Queue</span>.new   
    count = <span class="dv">0</span>                 <span class="co"># How many items?</span>
    each <span class="kw">do</span> |item|            <span class="co"># For each item</span>
      <span class="dt">Thread</span>.new <span class="kw">do</span>           <span class="co"># Create a new thread</span>
        q.enq(mapper[item])   <span class="co"># Map and enqueue mapped value</span>
      <span class="kw">end</span>
      count += <span class="dv">1</span>              <span class="co"># Count items</span>
    <span class="kw">end</span>

    t = <span class="dt">Thread</span>.new <span class="kw">do</span>         <span class="co"># Create injector thread</span>
      x = initial             <span class="co"># Start with specified initial value</span>
      <span class="kw">while</span>(count &gt; <span class="dv">0</span>)        <span class="co"># Loop once for each item</span>
        x = injector[x,q.deq] <span class="co"># Dequeue value and inject</span>
        count -= <span class="dv">1</span>            <span class="co"># Count down</span>
      <span class="kw">end</span>
      x                       <span class="co"># Thread value is injected value</span>
    <span class="kw">end</span>

    t.value   <span class="co"># Wait for injector thread and return its value</span>
  <span class="kw">end</span>
<span class="kw">end</span></code></pre></div>
<h4 id="condition-variables-and-queues">9.9.9 Condition Variables and Queues</h4>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">require <span class="st">&#39;thread&#39;</span>

<span class="kw">class</span> <span class="dt">Exchanger</span>
  <span class="kw">def</span> initialize
    <span class="co"># These variables will hold the two values to be exchanged.</span>
    <span class="ot">@first_value</span> = <span class="ot">@second_value</span> = <span class="dv">nil</span>
    <span class="co"># This Mutex protects access to the exchange method.</span>
    <span class="ot">@lock</span> = <span class="dt">Mutex</span>.new
    <span class="co"># This Mutex allows us to determine whether we&#39;re the first or</span>
    <span class="co"># second thread to call exchange.</span>
    <span class="ot">@first</span> = <span class="dt">Mutex</span>.new
    <span class="co"># This ConditionVariable allows the first thread to wait for</span>
    <span class="co"># the arrival of the second thread.</span>
    <span class="ot">@second</span> = <span class="dt">ConditionVariable</span>.new
  <span class="kw">end</span>

  <span class="co"># Exchange this value for the value passed by the other thread.</span>
  <span class="kw">def</span> exchange(value)
    <span class="ot">@lock</span>.synchronize <span class="kw">do</span>      <span class="co"># Only one thread can call this method at a time</span>
      <span class="kw">if</span> <span class="ot">@first</span>.try_lock      <span class="co"># We are the first thread</span>
        <span class="ot">@first_value</span> = value  <span class="co"># Store the first thread&#39;s argument</span>
        <span class="co"># Now wait until the second thread arrives.</span>
        <span class="co"># This temporarily unlocks the Mutex while we wait, so </span>
        <span class="co"># that the second thread can call this method, too</span>
        <span class="ot">@second</span>.wait(<span class="ot">@lock</span>)   <span class="co"># Wait for second thread </span>
        <span class="ot">@first</span>.unlock         <span class="co"># Get ready for the next exchange</span>
        <span class="ot">@second_value</span>         <span class="co"># Return the second thread&#39;s value</span>
      <span class="kw">else</span>                    <span class="co"># Otherwise, we&#39;re the second thread</span>
        <span class="ot">@second_value</span> = value <span class="co"># Store the second value</span>
        <span class="ot">@second</span>.signal        <span class="co"># Tell the first thread we&#39;re here</span>
        <span class="ot">@first_value</span>          <span class="co"># Return the first thread&#39;s value</span>
      <span class="kw">end</span>
    <span class="kw">end</span>
  <span class="kw">end</span>
<span class="kw">end</span></code></pre></div>
